{"assets":{
"script":[
{"Game":{
"type":"game script","start":"# current time\r
self.t = time_ms()\r
self.debug = False\r
\r
self.travelid = None\r
self.fpslog = int(self.t/1000)\r
self.fpscount = 0\r
\r
self.p = Player()\r
\r
#set_room('Demo_Room')\r
set_room('Starting_Room')\r
#set_room('Room1')","loop":"self.t = time_ms()\r
\r
self.fpscount += 1\r
ntime = int(self.t/1000)\r
\r
if ntime > self.fpslog:\r
    self.fpslog = ntime\r
    print(f\"Frames elapsed in last second: {self.fpscount
}\")\r
    self.fpscount = 0"
}
},
{"Player":{
"type":"object script","start":"# initialise pos, sprite
self.x = 0
self.y = 0
#self.z = 1000
self.sprite = new_sprite(\"debug.png\")

self.persistent = True

# velocity values
self.xv = 0
self.yv = 0
self.boostx, self.boosty = 0, 0

# For camera offset
self.y_off = 0
self.x_off = 0

# store previous values
self.x0 = 0
self.y0 = 0

self.spr_obg = Psprite()

# remove for hitbox debug
self.visible = False

self.scaleX = 2
self.scaleY = 2

self.xMOD = 0
self.yMOD = 0
self.xext = 0
self.yext = 0

self.dash_cool = game.t
self.damage_cool = game.t","loop":"camX, camY = camera_x(), camera_y()
xdist = (mouse_x()+camX) - self.x
ydist = (mouse_y()+camY) - self.y


# for arrow key movement
keys = [key_is_pressed('arrowRight'), 
        key_is_pressed('arrowLeft'), 
        key_is_pressed('arrowUp'),
        key_is_pressed('arrowDown')
]

# store previous position for movement rotation
self.x0, self.y0 = self.x, self.y

# prevent 0 trig errors
if not xdist and not ydist:
    xdist = 1

# get hypotenuse and adjust x & y for hyp of length 1
magn = hyp(xdist, ydist)
xdist, ydist = xdist/magn, ydist/magn


# move unless mouse is right on top of player
if mouse_is_pressed('left') and not magn < 25:
    do_move(self, xdist, ydist)

# allow for arrow-key movement
elif any(keys):
    xdist=ydist=0
    if keys[0
]: xdist = 1
    if keys[1
]: xdist = -1
    if keys[2
]: ydist = 1
    if keys[3
]: ydist = -1
    magn = hyp(xdist, ydist)
    xdist, ydist = xdist/magn, ydist/magn

    do_move(self, xdist, ydist)

else:
    # \"water resistance\" deteriorate velocity
    self.xv = deter(self.xv, 0.95)
    self.yv = deter(self.yv, 0.95)
    
# dash
if ((key_was_pressed(' ') or mouse_was_pressed('right')) and game.t > self.dash_cool):
    self.boostx = xdist*16
    self.boosty = ydist*16
    self.dash_cool = game.t + 420

#for external movement modifiers(boosters, jelly)
self.xext = (self.xMOD if abs(self.xMOD)>abs(self.xext) else self.xext)
self.yext = (self.yMOD if abs(self.yMOD)>abs(self.yext) else self.yext)

# deteriorate boost velocity
self.boostx, self.boosty = deter(self.boostx, 0.94), deter(self.boosty, 0.94)
#deteriorate external modif
self.xext, self.yext = deter(self.xext, 0.96), deter(self.yext, 0.94)

# final movement values in x and y
a, b = (self.xv+self.boostx+self.xext), (self.yv+self.boosty+self.yext)

self.x += a
self.y += b

self.xMOD, self.yMOD = 0, 0


# distance from zero after move
xdist = self.x - camX
ydist = self.y - camY

# really ugly code to update camera position
# either moves camera with delay following player or caps
# at set limits
new_camX = camX + (xdist - xdist/1.1) + self.x_off
new_camX = min(max(new_camX, game.cam_limit_x[0
]), game.cam_limit_x[1
])

new_camY = camY + (ydist - ydist/1.1) + self.y_off
new_camY = max(min(new_camY, game.cam_limit_y[0
]), game.cam_limit_y[1
])

set_camera(new_camX, new_camY)


# rotate in direction of movement
Dx, Dy = self.x-self.x0, self.y-self.y0
k0 = angle_helper(Dx, Dy)
if k0 != -361:
    self.angle = k0

update_spr(self.spr_obg, self.x, self.y, self.angle)






# Empty lines because I don't like it when code 
# is at the bottom of the screen"
}
},
{"gameplay":[
{"Block":{
"type":"object script","start":"#Block start
","loop":"
# Exit the loop early if far from player
pdistx = self.x - game.p.x
pdisty = self.y - game.p.y


if abs(pdistx) > 2200 or abs(pdisty) > 1600:
    self.visible = False
    return

self.visible = game.debug

pl = get_collision(self, \"Player\")
if pl:
    p_nf, p_sf, p_wf, p_ef = pl.y0+40, pl.y0-40, pl.x0-40, pl.x0+40

    if p_nf < self.sf or p_sf > self.nf:
        pl.y = pl.y0

    elif p_ef < self.wf or p_wf >= self.ef:
        pl.x = pl.x0
    
    # \"friction\" slowdown while colliding
    pl.xv = deter(pl.xv, 0.84)
    pl.yv = deter(pl.yv, 0.84)"
}
},
{"Booster":{
"type":"object script","start":"#Booster start
self.sprite = new_sprite(\"booster.png\")
self.scaleX = 1.5
self.scaleY = 1.5","loop":"#Booster loop

k = get_collision(self, \"Player\")
if k:
    boost(k, self.force, self.angle)
"
}
},
{"Bumper":{
"type":"object script","start":"#Bumper start
self.sprite = new_sprite(\"bumper.png\")
self.fl = False
self.scaleX = 1.5
self.scaleY = 1.5","loop":"#Bumper loop
k = get_collision(self, \"Player\")
if k and not self.fl:
    boost(k, self.force, k.angle-180)
    self.fl = True

if not k:
    self.fl = False

"
}
},
{"Current":{
"type":"object script","start":"self.sprite = new_sprite(\"debug.png\")
self.alpha = 0
self.c = 0","loop":"#Current loop

if not self.c%60:
    for i in range(self.dense):
        fx = random.randrange(self.x-self.w, self.x+self.w)
        fy = random.randrange(self.y-self.h, self.y+self.h)
        make_particle(fx, fy, self.xa, self.ya, \"current_particle.png\", self)

self.c += 1

k = get_collision(self, \"Player\")
if k:
    k.xMOD += self.xa
    k.yMOD += self.ya

"
}
},
{"textbox_inst":{
"type":"object script","start":"#TextBox start

self.sprite = sprite('text_box.png')

# TextBox class that created instance
self.parent = None","loop":"#TextBox loop

self.parent.do_loop()"
}
},
{"travelgate_inst":{
"type":"object script","start":"#travel_gate start

# reference to TravelGate class that created instance
self.parent = None","loop":"#travel_gate loop

if get_collision(self, 'Player'):
    self.parent.travel()"
}
}
]
},
{"Art":[
{"Psprite":{
"type":"object script","start":"#Hitbox start
self.z = 1000
self.scaleX = 1
self.scaleY = 1

self.sprite = new_sprite(\"octopus.png\")
spritesheet = sprite('dynamic_squid.png', 4, 4)
self.anim = animation(spritesheet, 10, 0, 12)
set_animation(self, self.anim)

self.persistent = True","loop":"#Psprite loop

"
}
},
{"Tile":{
"type":"object script","start":"# Empty (at least for now) class that is used to make tiles\r
# Sprite gets set anyways","loop":""
}
},
{"Particle":{
"type":"object script","start":"
","loop":"#Particle loop
if not (self.nb>=self.y>=self.sb) or not (self.wb<=self.x<=self.eb):
    destroy(self)

self.x += self.xv
self.y += self.yv
"
}
},
{"Background":{
"type":"object script","start":"#Background start

self.sprite = sprite('pixel_bg_stage1.png')
self.scaleX = 0.6
self.scaleY = 0.6","loop":"#Background loop

"
}
}
]
},
{"Whale":{
"type":"object script","start":"sprite_sheet = sprite('whalesheet_gap.png', 1, 4)
self.anim = animation(sprite_sheet, 4, 0, 3)
set_animation(self, self.anim)
self.scaleX = self.scaleY = 2

#self.sprite = sprite('whale.png')

self.x, self.y = 1500, -420
self.visible = True

self.frames = 0","loop":"try:
    # Exit the loop early if far from player
    pdist = get_dist(self.x, self.y, game.p.x, game.p.y)
    if pdist > 1700:
        if self.visible:
            self.visible = False
        return
    else:
        if not self.visible:
            self.visible = True
except AttributeError: # Whale created before player in Game start
    pass

if self.visible:
    d = self.frames % 100
    
    if 0 <= d < 50:
        self.y += 0.5
    if 50 <= d < 100:
        self.y -= 0.5
    
    self.frames += 1"
}
}
],
"room":[
{"Demo_Room":{
"type":"room script","start":"#Demo_Room start

game.bg = Background()
level = [
        '...CCC...',
        '..BL.RB..',
        '...L.R...',
        '...L.R...',
        '...L.R...',
        '...L.R...',
        '...LXR...',
        '...L.R...',
        '.VCC.CCV.',
        '.L.....R.',
        '.VBNBNNV.'
]
        
make_map(level)

w = Whale()

bigwhale = Whale()
bigwhale.scaleX = bigwhale.scaleY = 3.5
bigwhale.x = bigwhale.y = -700

createblock(0, 600, 300, 95)

make_current(0, 0, 200, 200, 5, 2)
make_current(500, -500, 400, 400, 0, 9)
make_booster(500, 0, 225)
make_booster(0, -500, -45)
make_bumper(-250, 500)

game.cam_limit_x = (-1310, 1310)
game.cam_limit_y = (504, -504)

TextBox('Welcome to the demo room', 1500)","loop":"#Demo_Room loop

"
}
},
{"Menu":{
"type":"room script","start":"#Menu start

","loop":"#Menu loop

"
}
},
{"Stage1":[
{"Starting_Room":{
"type":"room script","start":"self.roomid = '1-0'
game.cam_limit_x = (290, 1610)
game.cam_limit_y = (-110, -290)

if game.travelid == '1-1':
    smooth_tp(1900, -450)
    # game.p.x = 1900
    # game.p.y = -450
    # set_camera(1900, -450)


# game.bg = Background()
# game.bg.sprite = sprite('gradient1.png')


lvlmap = [
    '7CCCCCCCCCCCCCCCCCCCC6',
    'L....................R',
    'L..X.................R',
    'L....................R',
    'L....................R',
    'L....................2CCCC',
    'L.........................',
    'L.........................',
    '5VBNVBNNVNBBNVNVNBNBNVBNVN'

]

make_map(lvlmap)


# Make colliders
colliders = [
    (0, -400, 95, 900),
    (1050, 0, 2200, 95),
    (1250, -800, 2600, 95),
    (2100, -250, 95, 600),
    (2300, -500, 450, 95),

]

# From top left
blockgroup(-300, 200, colliders)

make_dark_gradient(2000, -450, 500, 400, 20)

self.gate = TravelGate(2220, -450, 60, 400, self.roomid, 'Room1')","loop":"#Starting_Room loop

"
}
},
{"Room1":{
"type":"room script","start":"self.roomid = '1-1'
game.cam_limit_x = (10, 1810)
game.cam_limit_y = (-110, -1090)

if game.travelid == '1-0':
    smooth_tp(-350, -50)
    # game.p.x = -350
    # game.p.y = -50
    # set_camera(game.p.x, game.p.y)

lvlmap = [
    '     7CCCCCCCCCCC6',
    'CCCCC3...........R',
    '......X..........R',
    '.................R',
    'NVBBV1...........R',
    '     L.........O.2CCCCCCC6',
    '     5VNNBNVV1...........R',
    '             L...........R',
    '             L...........2CCCCC',
    '             L.................',
    '             L.................',
    '             L...........0VNBVB',
    '             5VNNBNVB1...R      ',
    '                     L...R      ',
    '                     L...R      ',
    '                     L...R      ',
    '                     L...R      ',

]

make_map(lvlmap)


colliders = [
    (-350, 100, 600, 95),
    (-360, -200, 590, 95),
    (500, 200, 1300, 95),
    (-100, -310, 95, 290),
    (295, -400, 890, 95),
    (1100, -40, 95, 595)

]
blockgroup(0, 0, colliders)

colliders = [
    (605, 0, 890, 95),
    (-200, -405, 95, 690),
    (1000, -140, 95, 395),
    (190, -700, 895, 95),
    (1260, -300, 595, 95),
    (1260, -600, 595, 95),
    (600, -910, 95, 495),
    (1000, -860, 95, 595)

]
blockgroup(900, -300, colliders)

make_dark_gradient(-350, -50, 600, 400, 20, direction=False)
TravelGate(-560, -50, 60, 400, self.roomid, 'Starting_Room')

make_dark_gradient(1700, -1200, 500, 500, 20, vert=True)

make_dark_gradient(2150, -750, 600, 400, 20)


# Empty lines for scroll glitch


","loop":"#Room1 loop

"
}
}
]
},
{"Stage2":[

]
},
{"Stage3":[

]
}
],
"texture":[
{"tempTiles":[
{"ground1.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615954594.ground1.png"
}
},
{"ground2.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615954601.ground2.png"
}
},
{"ground3.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616115967.ground3.png"
}
},
{"ciel.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616116213.ciel.png"
}
},
{"wall_left.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616115833.wall_left.png"
}
},
{"wall_right.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615954627.wall_right.png"
}
},
{"in_corner_tl.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616112361.in_corner_tl.png"
}
},
{"in_corner_tr.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616112366.in_corner_tr.png"
}
},
{"in_corner_bl.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616112369.in_corner_bl.png"
}
},
{"in_corner_br.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616112375.in_corner_br.png"
}
},
{"out_corner_tl.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616116555.out_corner_tl.png"
}
},
{"out_corner_tr.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616116613.out_corner_tr.png"
}
},
{"out_corner_bl.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616116633.out_corner_bl.png"
}
},
{"out_corner_br.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616116652.out_corner_br.png"
}
},
{"greenblock.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1615959692.greenblock.png"
}
}
]
},
{"NPCs":[
{"whalesheet.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615951193.whalesheet.png"
}
},
{"whalesheet_gap.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615951543.whalesheet_gap.png"
}
},
{"whale.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.225782.1615757396.whale.png"
}
}
]
},
{"Player":[
{"octopus.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.225782.1615621603.octopus.png"
}
},
{"dynamic_squid.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615957753.dynamic_squid.png"
}
}
]
},
{"Stage1":[
{"Tiles1":[

]
},
{"Background1":[
{"gradient1.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615953211.gradient1.png"
}
},
{"pixel_bg_stage1.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615960001.pixel_bg_stage1.png"
}
}
]
}
]
},
{"Stage2":[
{"Tiles2":[

]
},
{"Background2":[
{"waterBG.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.225782.1615667719.waterBG.png"
}
}
]
}
]
},
{"Stage3":[
{"Tiles3":[

]
},
{"Background3":[

]
}
]
},
{"Gameplay_elements":[
{"bumper.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1616106674.bumper.png"
}
},
{"booster.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616112191.booster.png"
}
}
]
},
{"Misc":[
{"current_particle.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1616010007.current_particle.png"
}
}
]
},
{"debug.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1615942085.debug.png"
}
},
{"black40x40.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616018445.black40x40.png"
}
},
{"text_box.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616039356.text_box.png"
}
}
],
"sound":[

],
"function":[
{"imports.py":{
"type":"function script","head":"#File for imports to run before everything
import math
import time
import random

"
}
},
{"quickfuncs.py":{
"type":"function script","head":"#A collection of helper functions/enums.


def hyp(s, c) -> int:
    \"\"\"Return hypotenuse of right angle triangle.\"\"\"
    return math.sqrt((s**2)+(c**2))

def get_angle(y) -> float:
    \"\"\"Return angle of right angle triangle.
    
    Assumes hypotenuse is 1
    \"\"\"
    return math.degrees(math.asin(y))

def deter(val, k) -> int:
    \"\"\"Helper function that allows for movement deterioration
    while preventing rounding errors.\"\"\"
    if abs(val) <= 0.1: return 0
    return round(val*k, 3)

def get_dist(x1, y1, x2, y2):
    \"\"\"Return the distance between two points.\"\"\"
    return math.sqrt((x2-x1)**2 + (y2-y1)**2)

def do_move(pl, xdist, ydist):
    # Increase velocity
    pl.xv += (xdist*0.9)
    pl.yv += (ydist*0.9)
    
    # Get total velocity magnetude
    Vhyp = hyp(pl.xv, pl.yv)
    
    # Correct velocity speed
    if Vhyp > 6.5: # 6.5
        pl.xv = (pl.xv/Vhyp)*6.5
        pl.yv = (pl.yv/Vhyp)*6.5

def update_spr(plspr, x, y, angle):
    plspr.x = x
    plspr.y = y
    plspr.angle = angle

def angle_helper(Dx, Dy) -> int:
    \"\"\"This function returns the angle for an object moving in a specific direction.\"\"\"
    if not Dx and not Dy: Dx = 1
    m = hyp(Dx, Dy)
    Dy = Dy/m

    if m > 1:
        a = get_angle(Dy) - 90
        return a if Dx > 0 else -a
    
    return -361

def time_ms():
    return round(time.time() * 1000)

def boost(pl, force, angle):
    pl.xv = 0
    pl.yv = 0
    pl.boostx = 0
    pl.boosty = 0
    pl.xMOD += force * math.cos(math.radians(angle+90))
    pl.yMOD += force * math.sin(math.radians(angle+90))

def smooth_tp(x, y):
    \"\"\"Teleport the player to x and y and manage camera movement.\"\"\"

    offset_x = game.p.x - camera_x()
    offset_y = game.p.y - camera_y()
    game.p.x = x
    game.p.y = y

    new_camX = x + offset_x
    new_camY = y + offset_y
    new_camX = min(max(new_camX, game.cam_limit_x[0
]), game.cam_limit_x[1
])
    new_camY = max(min(new_camY, game.cam_limit_y[0
]), game.cam_limit_y[1
])
    set_camera(new_camX, new_camY)


"
}
},
{"make_map.py":{
"type":"function script","head":"tile_map = {
    'C': sprite('ciel.png'), # placeholder ceiling
    'L': sprite('wall_left.png'),
    'R': sprite('wall_right.png'),
    'V': sprite('ground1.png'),
    'B': sprite('ground2.png'),
    'N': sprite('ground3.png'),
    '0': sprite('in_corner_tl.png'),
    '1': sprite('in_corner_tr.png'),
    '2': sprite('in_corner_bl.png'),
    '3': sprite('in_corner_br.png'),
    '4': sprite('out_corner_tl.png'),
    '5': sprite('out_corner_tr.png'),
    '6': sprite('out_corner_bl.png'),
    '7': sprite('out_corner_br.png'),

}



def make_map(layout):
    for i in range(len(layout)):
        if 'X' in layout[i
]:
            origin = (layout[i
].index('X'), i)
    
    for i in range(len(layout)):
        for j in range(len(layout[i
])):
            if layout[i
][j
] in '. X':
                continue
            elif layout[i
][j
] not in tile_map.keys():
                print(f'Unrecognised \"{layout[i
][j
]
} in level map.')
                continue

            t = Tile()

            x = abs(100 * (origin[0
]-j))
            x *= -1 if j < origin[0
] else 1
            t.x = x

            y = abs(100 * (origin[1
]-i))
            y *= 1 if i < origin[1
] else -1
            t.y = y

            t.sprite = tile_map[layout[i
][j
]
]"
}
},
{"gamecreation.py":{
"type":"function script","head":"
def createblock(x, y, w, h):
    \"\"\"Basic opaque block. Takes args for pos, size, and optional block sprite.\"\"\"
    #construct block and set args
    a = Block()
    a.x = x
    a.y = y
    #This works for 40x40 sprite. For other sprites, change divisor accordingly
    a.sprite = new_sprite('debug.png') # For debugging
    a.scaleX = w/40
    a.scaleY = h/40
    
    a.visible = game.debug

    #store these for collision purposes
    a.wid = w/2
    a.ht = h/2
    a.nf = y+a.ht
    a.sf = y-a.ht
    a.wf = x-a.wid
    a.ef = x+a.wid
    
    return a

def blockgroup(x, y, posl):
    \"\"\"Creates a group of blocks at a x and y position,
    given a list  of block constructs. posl is a list of tuples,
    each of the form (x, y, w, h).\"\"\"
    for bx, by, bw, bh in posl:
        createblock(bx+x, by+y, bw, bh)

def make_current(x, y, w, h, xa, ya):
    \"\"\"Create a current block, which takes arguments for
    position, size, and acceleration values.\"\"\"
    inst = Current()
    inst.x = x
    inst.y = y
    inst.scaleX = w/40
    inst.scaleY = h/40
    inst.xa = xa
    inst.ya = ya

    inst.w = w/2
    inst.h = h/2
    inst.dense = (w*h)//6000
    
def make_particle(x, y, xv, yv, spr, proc):
    \"\"\"Create a particle with a linear velocity. 
    Pass in a parent process that will kill the particle later.\"\"\"
    inst =  Particle()
    inst.x = x
    inst.y = y
    inst.sprite = new_sprite(spr)
    inst.xv = xv
    inst.yv = yv
    inst.parent = proc
    inst.nb = proc.y + proc.h
    inst.sb = proc.y - proc.h
    inst.eb = proc.x + proc.w
    inst.wb = proc.x - proc.w
    inst.angle = angle_helper(xv, yv)

def make_booster(x, y, angle, force=30):
    \"\"\"A booster that launches you at a certain angle when touched.
    Force is given a default value, as for the sake of gameplay, faster boosters should
    be indicated as such to the player.\"\"\"
    inst = Booster()
    inst.x = x
    inst.y = y
    inst.angle = angle
    inst.force = force

def make_bumper(x, y, force=30):
    \"\"\"A bumper that always sends you in the opposite direction 
    from when you last bumped into it.\"\"\"
    inst = Bumper()
    inst.x = x
    inst.y = y
    inst.force = force


"
}
},
{"make_dark_gradient.py":{
"type":"function script","head":"def make_dark_gradient(x, y, w, h, levels, direction=True, vert=False, over=True):
    \"\"\"Make a fade to black gradient centered around x, y of width
    w and height h.
    
    Arg \"levels\" specifies the number of steps to divide the gradient into
    Arg \"direction\" is True if top/left should be the lightest part
    Arg \"vert\" is True if gradient should be vertical
    Arg \"over\" decides if the gradient should go over the player
    \"\"\"
    
    width = w/levels if not vert else w
    height = h/levels if vert else h

    for i in range(levels):
        t = Tile()
        t.sprite = sprite('debug.png') if game.debug else sprite('black40x40.png')
        t.scaleX = (width/40)
        t.scaleY = (height/40)
        
        if vert:
            t.x = x 
            t.y = ((y + (h/2)) - (height/2)) - (height * i)
        else:
            t.x = (x - (w/2) + (width/2)) + (width * i)
            t.y = y

        t.alpha = (1/(levels-1)) * i if direction else 1 - ((1/(levels-1)) * i)

        if over: t.z = 1001"
}
},
{"Classes":[
{"TravelGate.py":{
"type":"function script","head":"class TravelGate:
    def __init__(self, x, y, w, h, roomid, dest):
        self.inst = travelgate_inst()
        self.inst.parent = self
        self.inst.x = x
        self.inst.y = y
        
        self.inst.sprite = sprite('debug.png') if game.debug else sprite('black40x40.png')
        self.inst.visible = game.debug
        self.inst.scaleX = w/40
        self.inst.scaleY = h/40

        self.roomid = roomid
        self.dest = dest

    def travel(self):
        game.travelid = self.roomid
        set_room(self.dest)"
}
},
{"TextBox.py":{
"type":"function script","head":"class TextBox:
    def __init__(self, msg, duration):
        \"\"\"Create a textbox with msg text that last for a 
        minimum of duration ms.\"\"\"\"

        # clear any current text box
        try:
            destroy(game.text_box)
        # no text box currently up
        except AttributeError:
            pass

        self.inst = textbox_inst()
        self.inst.parent = self
        self.inst.x = camera_x()
        self.inst.y = camera_y() - 200
        
        self.text = text(msg, self.inst.x - 450, self.inst.y + 40)
        self.text.color = '#ffffff'
        self.text.fontsize = 70
        self.text.fontFamily = 'courier new'

        self.close_time = game.t + duration
    
    def do_loop(self):
        self.inst.x = camera_x()
        self.inst.y = camera_y() - 200

        self.text.x = self.inst.x - 450
        self.text.y = self.inst.y + 40

        if game.t > self.close_time:
            keys = (
                mouse_is_pressed('left'),
                mouse_is_pressed('right'),
                key_is_pressed('arrowRight'),
                key_is_pressed('arrowLeft'),
                key_is_pressed('arrowDown'),
                key_is_pressed('arrowUp'),
                key_is_pressed(' ')
            )

            if any(keys):
                destroy(self.inst)
                destroy(self.text)
                game.text_box = None"
}
}
]
}
]
}
}