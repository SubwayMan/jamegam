{"assets":{
"script":[
{"Game":{
"type":"game script","start":"# current time\r
self.t = time_ms()\r
# general purpose frame counter\r
self.c = 0\r
\r
self.debug = True\r
self.showgrid = False\r
# create grid guides\r
if self.showgrid:\r
    for i in range(-20, 21):\r
        for j in range(-10, 11):\r
            temp = Slate()\r
            temp.x = i*100\r
            temp.y = j*100\r
            temp.sprite = new_sprite(\"Guide.png\")\r
            temp.persistent = True\r
            temp.scaleX = 0.6\r
            temp.scaleY = 0.6\r
            temp.z = 150\r
\r
self.travelid = None\r
self.fpslog = int(self.t/1000)\r
self.fpscount = 0\r
\r
self.dark = False\r
\r
self.prog = ProgTracker()\r
self.prog.visible = False\r
self.npcs = [
]\r
self.e = False\r
self.p = Player()\r
self.bg = Background()\r
\r
# set_room('Demo_Room')\r
\r
self.music = SoundManager()\r
self.music.persistent = True\r
self.music.visible = False\r
set_room('R3_B')","loop":"self.t = time_ms()\r
self.c += 1\r
\r
self.fpscount += 1\r
ntime = int(self.t/1000)\r
\r
if ntime > self.fpslog:\r
    self.fpslog = ntime\r
    print(f\"Frames elapsed in last second: {self.fpscount
}\")\r
    self.fpscount = 0"
}
},
{"Player":{
"type":"object script","start":"# initialise pos, sprite
self.x = 0
self.y = 0
self.z = 11
self.sprite = new_sprite(\"debug.png\")
self.scaleX = 1
self.scaleY = 1
self.rad = self.scaleX*20
self.persistent = True

# velocity values
self.xv = 0
self.yv = 0
self.boostx, self.boosty = 0, 0

# For camera offset
self.y_off = 0
self.x_off = 0

# store previous values
self.x0 = 0
self.y0 = 0

# sprite that user normally sees
self.spr_obj = Psprite()
# flag for determining animation vs static
self.moving = False

# for debug mode
self.visible = game.debug

self.xMOD = 0
self.yMOD = 0
self.cxMOD = 0
self.cyMOD = 0

self.xext = 0
self.yext = 0
self.cxext = 0
self.cyext = 0


self.dash_cool = game.t
self.damage_cool = game.t
self.dmgF = True

self.hp = 5
self.healthbar = HealthInd()
self.healthbar.sprite = self.healthbar.spritemap[self.hp
]
self.healthbar.prev_h = self.hp","loop":"camX, camY = camera_x(), camera_y()
xdist = (mouse_x()+camX) - self.x
ydist = (mouse_y()+camY) - self.y


# for arrow key movement
keys = [key_is_pressed('arrowRight'), 
        key_is_pressed('arrowLeft'), 
        key_is_pressed('arrowUp'),
        key_is_pressed('arrowDown')
]

# store previous position for movement rotation
self.x0, self.y0 = self.x, self.y

# prevent 0 trig errors
if not xdist and not ydist:
    xdist = 1

# get hypotenuse and adjust x & y for hyp of length 1
magn = hyp(xdist, ydist)
xdist, ydist = xdist/magn, ydist/magn


# move unless mouse is right on top of player
if mouse_is_pressed('left') and not magn < 25:
    do_move(self, xdist, ydist)

# allow for arrow-key movement
elif any(keys):
    xdist=ydist=0
    if keys[0
]: xdist = 1
    if keys[1
]: xdist = -1
    if keys[2
]: ydist = 1
    if keys[3
]: ydist = -1
    magn = hyp(xdist, ydist)
    xdist, ydist = xdist/magn, ydist/magn

    do_move(self, xdist, ydist)

else:
    # \"water resistance\" deteriorate velocity
    self.xv = deter(self.xv, 0.95)
    self.yv = deter(self.yv, 0.95)
    
# dash
if ((key_was_pressed(' ') or mouse_was_pressed('right')) and game.t > self.dash_cool):
    self.boostx = xdist*16
    self.boosty = ydist*16
    self.dash_cool = game.t + 600

#for external movement modifiers(boosters, jelly)
self.xext = (self.xMOD if abs(self.xMOD)>abs(self.xext) else self.xext)
self.yext = (self.yMOD if abs(self.yMOD)>abs(self.yext) else self.yext)

#current (ugly fix)
self.cxext = (self.cxMOD if abs(self.cxMOD)>abs(self.cxext) else self.cxext)
self.cyext = (self.cyMOD if abs(self.cyMOD)>abs(self.cyext) else self.cyext)

# deteriorate boost velocity
self.boostx, self.boosty = deter(self.boostx, 0.94), deter(self.boosty, 0.94)
#deteriorate external modif & current
self.xext, self.yext = deter(self.xext, 0.96), deter(self.yext, 0.96)
self.cxext, self.cyext = deter(self.cxext, 0.96), deter(self.cyext, 0.94)

# final movement values in x and y
a, b = (self.xv+self.boostx+self.xext+self.cxext), (self.yv+self.boosty+self.yext+self.cyext)

self.x += a
self.y += b

self.xMOD, self.yMOD = 0, 0
self.cxMOD, self.cyMOD = 0, 0

# start or stop animation based on speed
if abs(a) + abs(b) > 2:
    if not self.moving:
        set_animation(self.spr_obj, self.spr_obj.anim)
        self.moving = True
else:
    if self.moving:
        self.spr_obj.sprite = self.spr_obj.static
        self.moving = False

# distance from camera after move
xdist = self.x - camX
ydist = self.y - camY

# update camera position either moves camera with delay
# following player or caps at set limits
new_camX = camX + (xdist - xdist/1.1) + self.x_off
new_camX = min(max(new_camX, game.cam_limit_x[0
]), game.cam_limit_x[1
])

new_camY = camY + (ydist - ydist/1.1) + self.y_off
new_camY = max(min(new_camY, game.cam_limit_y[0
]), game.cam_limit_y[1
])

set_camera(new_camX, new_camY)


# rotate in direction of movement
Dx, Dy = self.x-self.x0, self.y-self.y0
k0 = angle_helper(Dx, Dy)
if k0 != -361:
    self.angle = k0

update_spr(self.spr_obj, self.x, self.y, self.angle)

if game.npcs:
    npc_dists = [get_dist(o.x, o.y, self.x, self.y) for o in game.npcs
]
    near = min(npc_dists)
    if near < 150:
        n = game.npcs[npc_dists.index(near)
]
        if not n.e_popup:
            create_e(n)
        if key_was_pressed('e'):
            create_msg(n)
    else:
        if game.e:
            destroy(game.e)
        for o in game.npcs:
            if o.e_popup:
                o.e_popup = False


game.bg.x += (Dx*0.6)
game.bg.y += (Dy*0.6)

if key_was_pressed('f'):
    make_echo(self.x, self.y, self.angle)

# damage invincibility management
if self.damage_cool < game.t and not self.dmgF:
    self.dmgF = True
    self.spr_obj.alpha = 1
   
# death check
if self.hp < 1:
    set_room(get_room().__name__)
    self.hp = 5
    # stop movement
    self.xv = self.yv = self.boostx = self.boosty = 0
    self.xext = self.yext = self.xMOD = self.yMOD = 0



# Empty lines because I don't like it when code 
# is at the bottom of the screen"
}
},
{"Conventions":{
"type":"object script","start":"#This is for storing reference for future ease of use.

#==================== Z REFERENCE =======================
#Place any non-zero Z values here for reference, so we don't end up 
#setting objects to z-403285245 to place objects on top.
#BACKGROUND: -10
#Dark area (black tiles): -5
#Spikes: 8
#Tiles: 9
#Player sprite: 10
#Player debug: 11
#Dark gradients: 24
#Text boxes: 25
#Health indicator: 26
#If you come across an undocumented Z-value, add it here.","loop":""
}
},
{"gameplay":[
{"Block":{
"type":"object script","start":"#Block start
","loop":"
# Exit the loop early if far from player
pdistx = self.x - game.p.x
pdisty = self.y - game.p.y


if abs(pdistx) > 2200 or abs(pdisty) > 1600:
    self.visible = False
    return

pl = get_collision(self, \"Player\")
if pl:
    p_nf, p_sf, p_wf, p_ef = pl.y0+pl.rad, pl.y0-pl.rad, pl.x0-pl.rad, pl.x0+pl.rad

    if p_nf < self.sf or p_sf > self.nf:
        pl.y = pl.y0

    elif p_ef < self.wf or p_wf >= self.ef:
        pl.x = pl.x0
    
    # \"friction\" slowdown while colliding
    pl.xv = deter(pl.xv, 0.84)
    pl.yv = deter(pl.yv, 0.84)

al = get_collision(self, \"Anglerfish\")
if al:
    a_nf, a_sf, a_wf, a_ef = al.y0+40, al.y0-40, al.x0-40, al.x0+40

    if a_nf < self.sf or a_sf > self.nf:
        al.y = al.y0

    elif a_ef < self.wf or a_wf >= self.ef:
        al.x = al.x0"
}
},
{"Booster":{
"type":"object script","start":"#Booster start

self.disp = Slate()
spritesheet = sprite(\"boostersheet.png\", 4, 3)
self.anim = animation(spritesheet, 15, 0, 10)
set_animation(self.disp, self.anim)

filterConfig = {
    \"threshold\": 0.7,
    \"bloomScale\" : 2,
    \"brightness\" : 0.4,
    \"blur\" : 2,
    \"quality\" : 10,

}

advBloom = new_adv_bloom_filter(filterConfig)
add_filter(self.disp, advBloom)

self.sprite = sprite('debug.png')
self.visible = game.debug

self.scaleX = 1.4
self.scaleY = 1.4","loop":"#Booster loop

k = get_collision(self, \"Player\")
if k:
    boost(k, self.force, self.angle)
"
}
},
{"Bumper":{
"type":"object script","start":"#Bumper start

self.disp = Slate()
self.disp.scaleX = self.disp.scaleY = 0.6
spritesheet = sprite(\"bouncesheet.png\", 2, 1)
self.anim = animation(spritesheet, 2, 0, 1)
set_animation(self.disp, self.anim)

filterConfig = {
    \"threshold\": 0.825,
    \"bloomScale\" : 2,
    \"brightness\" : 0.3,
    \"blur\" : 2,
    \"quality\" : 10,

}

advBloom = new_adv_bloom_filter(filterConfig)
add_filter(self.disp, advBloom)

self.sprite = sprite('debug.png')
self.visible = game.debug

self.fl = False
self.scaleX = 1.3
self.scaleY = 1.3","loop":"#Bumper loop
k = get_collision(self, \"Player\")
if k and not self.fl:
    boost(k, self.force, k.angle-180)
    self.fl = True

if not k:
    self.fl = False

"
}
},
{"Current":{
"type":"object script","start":"self.sprite = new_sprite(\"debug.png\")
self.alpha = 0

#if temporary
self.temp = False
self.exp_time = 0

# offset from game counter to create particles right away
self.count_offset = game.c%40 + 1","loop":"#Current loop

if not (game.c - self.count_offset)%40:
    for i in range(self.dense):
        fx = random.randrange(self.x-self.w, self.x+self.w)
        fy = random.randrange(self.y-self.h, self.y+self.h)
        spr = 'current_particle_dark.png' if game.dark else 'current_particle.png'
        make_particle(fx, fy, self.xa, self.ya, spr, self)

k = get_collision(self, \"Player\")
if k:
    k.cxMOD += self.xa
    k.cyMOD += self.ya

if self.temp and game.t>self.exp_time:
    destroy(self)"
}
},
{"textbox_inst":{
"type":"object script","start":"#TextBox start

self.sprite = sprite('text_box.png')

# TextBox class that created instance
self.parent = None","loop":"#TextBox loop

self.parent.do_loop()"
}
},
{"Spike":{
"type":"object script","start":"#Spike start

self.fading = False
if game.dark:
    self.sprite = sprite(\"Spike1_dark.png\")
    self.alpha = 0
else:
    self.sprite = sprite(\"Spike1.png\")","loop":"#Spike loop
l = get_collision(self, \"Player\")
if l and l.dmgF:
    boost(l, 8, l.angle-180)
    damage(1)

if game.dark:
    if get_collision(self, 'Echolocation'):
        self.alpha = 1
        self.fading = True
    if self.fading:
        self.alpha -= 0.02
        if self.alpha <= 0:
            self.alpha = 0
            self.fading = False"
}
},
{"Hurtbox":{
"type":"object script","start":"self.sprite = new_sprite(\"debug.png\")
self.alpha = 0
#if temporary
self.temp = False
self.exp_time = 0
#Func holds a function that describes player movement after hurtbox collision.
#Can be redefined externally.
self.func = lambda a, l: boost(l, 10, l.angle-180)

if game.debug:
    self.alpha = 0.8","loop":"#Hurtbox loop
k = get_collision(self, \"Player\")

if k and k.dmgF:
    damage(self.dmg)
    self.func(self, k)

if self.temp and game.t > self.exp_time:
    destroy(self)"
}
},
{"Anglerfish":{
"type":"object script","start":"self.scale = 1

self.sprite = sprite(\"Anglerfish_dark.png\") if game.dark else sprite(\"Anglerfish.png\")

self.light = Slate()
self.light.sprite = new_sprite(\"Anglerfish_light.png\")
filterConfig = {
    \"threshold\": 0.5,
    \"bloomScale\" : 2,
    \"brightness\" : 1,
    \"blur\" : 2,
    \"quality\" : 10,

}
advBloom = new_adv_bloom_filter(filterConfig)
add_filter(self.light, advBloom)


self.scaleX = self.scale
self.scaleY = self.scale

transform(self.light, self.x, self.y, self.scale, self.scale)
self.alpha = 0
self.disabled = False
self.fading = False

self.x0 = 0
self.y0 = 0

self.h = make_hurtbox(self.x+30, self.y, 20, 20, 2)
self.h.parent = self
self.h.func = lambda s, pl: boost(pl, 10, s.parent.angle-90)","loop":"if self.disabled:
    return
self.x0 = self.x
self.y0 = self.y

dx = game.p.x - self.x 
dy = game.p.y - self.y

# reaction uppon approach
if hyp(dx, dy) < 200:
    if not game.dark:
        self.alpha = min(1, self.alpha+0.1)
    self.angle = angle_helper(dx, dy) + 90
    mod = 2/hyp(dx, dy)    
    self.x += dx*mod
    self.y += dy*mod
    if dx < 0:
        self.scaleY = -self.scale
    else:
        self.scaleY = self.scale
else:
    if not game.dark:
        self.alpha = max(0, self.alpha-0.1)

transform(self.light, self.x, self.y)
self.light.angle = self.angle
self.light.scaleY = self.scaleY

hitbox_rotate(self.h, self, self.angle, 30)

if game.dark:
    if get_collision(self, 'Echolocation'):
        self.alpha = 1
        self.fading = True
    if self.fading:
        self.alpha -= 0.02
        if self.alpha <= 0:
            self.alpha = 0
            self.fading = False"
}
},
{"Jellyfish":{
"type":"object script","start":"if game.dark:
    spritesheet = sprite(\"jelly_dark.png\", 1, 8)
else:
    spritesheet = sprite(\"jelly.png\", 1, 8)

self.anim = animation(spritesheet, 4, 0, 7)

self.fading = False
if game.dark:
    self.alpha = 0
else:
    set_animation(self, self.anim)

self.scaleX = 0.5
self.scaleY = 0.5

#bounce cap
self.bounce_h = Jellycap()
self.bounce_h.scaleX = 1.3
self.bounce_h.scaleY = 0.5","loop":"if game.dark:
    if get_collision(self, 'Echolocation'):
        self.alpha = 1
        self.fading = True
        set_animation(self, self.anim)
    if self.fading:
        self.alpha -= 0.02
        if self.alpha <= 0:
            self.alpha = 0"
}
},
{"Jellycap":{
"type":"object script","start":"#Helper class - special kind of booster for jellyfish caps
self.sprite = new_sprite(\"debug.png\")
self.z = 100
if not game.debug:
    self.alpha = 0
    
#prevent double collisions
self.mcf = False
","loop":"#Jellycap loop
k = get_collision(self, \"Player\")
if k and not self.mcf:
    f0 = (2*self.angle) - (k.angle-180)
    boost(k, 20, f0)
    self.mcf = True

if not k:
    self.mcf = False
"
}
},
{"Echolocation":{
"type":"object script","start":"self.sprite = sprite('sonar_beam.png')
self.angle = game.p.angle
self.scaleX = 0.3
self.scaleY = 0.5

self.deathtime = game.c + 40","loop":"self.x += self.xvel\r
self.y += self.yvel\r
self.scaleX += 0.08\r
self.scaleY += 0.06\r
\r
if game.dark:\r
    t_col = get_collision_list(self, 'Tile')\r
    if t_col:\r
        for t in t_col:\r
            t.alpha = 1\r
            t.fading = True\r
\r
if game.c > self.deathtime:\r
    destroy(self)"
}
},
{"travelgate_inst":{
"type":"object script","start":"#travel_gate start

# reference to TravelGate class that created instance
self.parent = None","loop":"#travel_gate loop

if get_collision(self, 'Player'):
    self.parent.travel()"
}
},
{"Nautilus":{
"type":"object script","start":"#Nautilus start
self.spr = Slate()
self.hitbox = make_hurtbox(0, 0, 200, 200, 1, lambda a, l: boost(l, 20, l.angle-180))
self.hitbox.alpha = 1
self.spr.sprite = new_sprite(\"debug.png\")


","loop":"#Nautilus loop

"
}
},
{"Swordfish":{
"type":"object script","start":"#Swordfish start

self.active = False
self.alert = True

self.fading = False
if game.dark:
    self.sprite = sprite(\"Swordfish_dark.png\")
    self.alpha = 0
else:
    self.sprite = sprite(\"Swordfish.png\")


self.h = make_hurtbox(self.x+30, self.y, 20, 20, 2)
self.h.parent = self
self.h.func = lambda s, pl: boost(pl, 10, s.parent.angle-90)","loop":"#Swordfish loop
if not self.ai:
    return

if self.alert and not self.active:
    Dx, Dy = game.p.x - self.x, game.p.y - self.y
    k = angle_helper(Dx, Dy) + 90
    if abs((self.angle - k)%360) < 10:
        self.active = True

if self.alert and self.active:
    i = (20*math.cos(math.radians(self.angle)))
    j = (20*math.sin(math.radians(self.angle)))
    self.x += i
    self.y += j
    self.h.x += i
    self.h.y += j
    k = get_collision(self.h, \"Block\")
    if k:
        self.alert = False
        destroy(self.h)


if game.dark:
    if get_collision(self, 'Echolocation'):
        self.alpha = 1
        self.fading = True
    if self.fading:
        self.alpha -= 0.02
        if self.alpha <= 0:
            self.alpha = 0
            self.fading = False"
}
},
{"boss_spike":{
"type":"object script","start":"self.wait = game.t + 600
self.idle = True
self.sprite = new_sprite(\"Boss_Spike.png\")
self.scaleX = 2
self.scaleY = 2","loop":"#boss_spike loop
if self.idle and game.t > self.wait:
    self.idle = False
    Dx, Dy = game.p.x - self.x, game.p.y - self.y
    theta = angle_helper(Dx, Dy)
    self.angle = theta
    self.xv = math.acos(math.radians(self.angle)) * 25
    self.yv = math.asin(math.radians(self.angle)) * 25

if not self.idle:
    self.x += self.xv
    self.y += self.yv

pl = get_collision(self, \"Player\")
if pl:
    damage(pl, 1)
    destroy(self)

if game.t - self.wait > 3000:
    destroy(self)
"
}
}
]
},
{"Art":[
{"Psprite":{
"type":"object script","start":"#Hitbox start
self.z = 10
self.scaleX = 0.7
self.scaleY = 0.7


self.static = sprite('player_still.png')
spritesheet = sprite('dynamic_squid.png', 4, 4)
self.anim = animation(spritesheet, 10, 0, 12)

self.sprite = self.static
# set_animation(self, self.anim)

self.persistent = True","loop":"#Psprite loop

"
}
},
{"Tile":{
"type":"object script","start":"# Empty (at least for now) class that is used to make tiles\r
# Sprite gets set anyways\r
\r
\r
if game.dark:\r
    self.alpha = 0\r
self.fading = False","loop":"if game.dark:\r
    if self.fading:\r
        self.alpha -= 0.02\r
        if self.alpha <= 0:\r
            self.alpha = 0\r
            self.fading = False"
}
},
{"Particle":{
"type":"object script","start":"if game.dark:
    self.alpha = 0
self.fading = False
self.scaleX = 1.3
self.scaleY = 1.3","loop":"#Particle loop
if not (self.nb>=self.y>=self.sb) or not (self.wb<=self.x<=self.eb):
    destroy(self)

self.x += self.xv
self.y += self.yv

if game.dark:
    if get_collision(self, 'Echolocation'):
        self.alpha = 1
        self.fading = True
    if self.fading:
        self.alpha -= 0.02
        if self.alpha <= 0:
            self.alpha = 0
            self.fading = False"
}
},
{"Slate":{
"type":"object script","start":"#A blank object that can be used in any way by any other object.","loop":""
}
},
{"HealthInd":{
"type":"object script","start":"self.spritemap = {
    5: sprite('health_5.png'),
    4: sprite('health_4.png'),
    3: sprite('health_3.png'),
    2: sprite('health_2.png'),
    1: sprite('health_1.png'),
    0: sprite('health_0.png'),

}

self.persistent = True

self.x = -460
self.y = 180
self.scaleX = self.scaleY = 0.2

# just here for reference, gets set by player class
self.prev_h = None

self.z = 26","loop":"if game.p.hp != self.prev_h:
    self.sprite = self.spritemap[game.p.hp
]
self.prev_h = game.p.hp

self.x = camera_x() - 540
self.y = camera_y() + 260"
}
},
{"Background":{
"type":"object script","start":"#Background start

self.x = 0
self.y = 0
self.scaleX = 0.6
self.scaleY = 0.6
self.z = -10
self.persistent = True","loop":"#Background loop

if game.dark == self.visible:
    self.visible = not self.visible"
}
}
]
},
{"Whale":{
"type":"object script","start":"sprite_sheet = sprite('whalesheet_gap.png', 1, 4)
self.anim = animation(sprite_sheet, 4, 0, 3)
set_animation(self, self.anim)

self.scaleX = self.scaleY = 2
self.e_offset = 100

self.x, self.y = 1500, -420
self.visible = True

self.msg = 'Hi! I\\'m a whale!'","loop":"try:
    # Exit the loop early if far from player
    pdist = get_dist(self.x, self.y, game.p.x, game.p.y)
    if pdist > 1700:
        if self.visible:
            self.visible = False
        return
    else:
        if not self.visible:
            self.visible = True
except AttributeError: # Whale created before player in Game start
    pass

if self.visible:
    d = game.c % 100
    
    if 0 <= d < 50:
        self.y += 0.5
    if 50 <= d < 100:
        self.y -= 0.5

pX, pY = game.p.x, game.p.y
"
}
},
{"SoundManager":{
"type":"object script","start":"#SONG CREDIT: Terminus by meganeko

#SoundManager start
self.queue = [
]

#Uses time in seconds
self.orig = game.t // 1000

#Maps songs to their length for scheduling
#Key: mood no. -1
self.sl = [40, 36, 33, 36, 16, 29, 29, 30
]

#Store current song.
self.song = None

","loop":"#SoundManager loop

"
}
}
],
"room":[
{"Demo_Room":{
"type":"room script","start":"#Demo_Room start

game.bg = Background()
level = ['...CCC...','..BL.RB..','...L.R...','...L.R...', '...L.R...','...L.R...', '...LXR...', '...L.R...','.VCC.CCV.', '.L.....R.', '.VBNBNNV.'
]
        
make_map(level)

w = Whale()

bigwhale = Whale()
bigwhale.scaleX = bigwhale.scaleY = 3.5
bigwhale.x = bigwhale.y = -700

createblock(0, 600, 300, 95)

make_current(0, 0, 200, 200, 5, 2)
make_current(500, -500, 400, 400, 0, 9)
make_booster(500, 0, 225)
make_booster(0, -500, -45)
make_bumper(-250, 500)

game.cam_limit_x = (-1310, 1310)
game.cam_limit_y = (504, -504)

TextBox('Welcome to the demo room', 1500)","loop":"#Demo_Room loop

"
}
},
{"Menu":{
"type":"room script","start":"#Menu start

","loop":"#Menu loop

"
}
},
{"Stage1":[
{"Starting_Room":{
"type":"room script","start":"self.roomid = '0-1'

game.npcs.clear()
game.dark = False
game.cam_limit_x = (290, 1610)
game.cam_limit_y = (-110, -290)

if game.travelid == '0-0':
    smooth_tp(1900, -450)
else:
    smooth_tp(0, 0)

lvlmap = [
    '7CCCCCCCCCCCCCCCCCCCC6',
    'L....................R',
    'L..X.................R',
    'L....................R',
    'L....................R',
    'L....................2CCCC',
    'L.........................',
    'L.........................',
    '5VBNVBNNVNBBNVNVNBNBNVBNVN'

]
make_map(lvlmap)

game.bg.sprite = new_sprite(\"purple_bg.png\")
game.bg.scaleX = 2

# Make colliders
colliders = [
    (0, -400, 95, 900),
    (1050, 0, 2200, 95),
    (1250, -800, 2600, 95), 
    (2300, -250, 495, 595),

]

# From top left
blockgroup(-300, 200, colliders)

make_dark_gradient(2000, -450, 500, 400, 20)

self.gate = TravelGate(2220, -450, 60, 400, self.roomid, 'Hub_Room')

make_simple_npc(500, -500, 'Whale', 'Howdy stranger, I\\'m William the whale!\
I was supposed to tell you how to move, but you had to move\
to get to me, huh? No tutorial for you!\
Proceed to the bottom right.')

play_track(game.music, 2)","loop":"#Starting_Room loop

"
}
},
{"Hub_Room":{
"type":"room script","start":"game.npcs.clear()
game.dark = False

self.roomid = '0-0'
game.cam_limit_x = (10, 1810)
game.cam_limit_y = (-110, -1090)

if game.travelid == '0-1':
    smooth_tp(-350, -50)
elif game.travelid == '1-0':
    smooth_tp(1700, -1300)
else:
    smooth_tp(0, 0)

lvlmap = [
    '     7CCCCCCCCCCC6             ',
    'CCCCC3...........R             ',
    '......X..........R             ',
    '.................R             ',
    'NVBBV1...........R             ',
    '     L...........2CCCCCCC6     ',
    '     5NNNNNNNN1..........R     ',
    '     7CCCCCCCC3..........R     ',
    '     L...................2CCCCC',
    '     L.........................',
    '     L.........................',
    '     L...................0VNBVB',
    '     5VNNNNNNNVNNBNVB1...R     ',
    '                     L...R     ',
    '                     L...R     ',
    '                     L...R     ',
    '                     L...R     ',

]
make_map(lvlmap)
game.bg.sprite = new_sprite(\"purple_bg.png\")
game.bg.x, game.bg.y = -100, -300
game.bg.scaleX = 2
game.bg.scaleY = 1.5

# from (0, 0)
colliders = [
    (-350, 100, 600, 95),
    (-350, -700, 595, 1095),
    (500, 200, 1300, 95),
    (300, -1300, 895, 695),
    (1500, -50, 895, 595),
    (400, -450, 900, 200),

]
blockgroup(0, 0, colliders)

# from (900, -300)
colliders = [
    (1250, -150, 595, 395),
    (200, -900, 895, 495),
    (1250, -850, 595, 595)

]
blockgroup(900, -300, colliders)

make_simple_npc(1500, -800, 'Whale', 'Hi, I\\'m Winona the Whale!\
You completed this challenge! More to come soon...')


make_dark_gradient(-350, -50, 600, 400, 20, direction=False)
TravelGate(-560, -50, 60, 400, self.roomid, 'Starting_Room')

make_dark_gradient(1700, -1200, 500, 500, 20, vert=True)
TravelGate(1700, -1400, 500, 60, self.roomid, 'R1_0')

make_dark_gradient(2150, -750, 600, 400, 20)
stop_track(game.music)
play_track(game.music, 6)
# Empty lines for scroll glitch


","loop":"#Room1 loop

"
}
},
{"R0_2":{
"type":"room script","start":"#R0_2 start

","loop":"#R0_2 loop

"
}
},
{"R1_0":{
"type":"room script","start":"game.npcs.clear()
game.dark = False

# ROOM ID - used for determining location when going to other rooms
self.roomid = '1-0'

game.cam_limit_x = (-10, 1610)
game.cam_limit_y = (290, -190)

if game.travelid == '0-0':
    smooth_tp(750, 400)
elif game.travelid == '1-1':
    smooth_tp(1950, -250)
elif game.travelid == '1-10':
    smooth_tp(-400, -250)
else:
    smooth_tp(0, 0)



# X is (0, 0)
lvlmap = [
    '            L..R         ',
    '            L..R         ',
    '            L..R         ',
    '            L..R         ',
    '    7CCCCCCC3..2CCCCCCCC6',
    '    L...................R',
    '    L.X.................R',
    'CCCC3...................2CCCC',
    '.............................',
    '.............................',
    'NVBB1...................0VBNN',
    '    5BNVBNNVNBBNVNVNBNBN4'

]
make_map(lvlmap)

game.bg.sprite = sprite(\"purple_bg.png\")
game.bg.x, game.bg.y = 300, -100
game.bg.scaleX = 2
game.bg.scaleY = 2

# make colliders
colliders = [
    (-200, -150, 495, 395),
    (-200, -650, 495, 195),
    (400, 200, 895, 495),
    (1550, 200, 995, 495),
    (1000, -700, 2100, 95),
    (2200, -150, 495, 395),
    (2200, -650, 495, 195)

]

# from top left
blockgroup(-200, 200, colliders)

make_current(575, -150, 350, 600, 1, -12)
make_current(925, -150, 350, 600, -5, 12)

make_current(1800, -250, 600, 300, -9, 0)

make_dark_gradient(2000, -250, 500, 400, 20)
TravelGate(2220, -250, 60, 400, self.roomid, 'R1_1')

make_dark_gradient(750, 400, 400, 500, 20, direction=False, vert=True)
TravelGate(750, 600, 400, 60, self.roomid, 'Hub_Room')

make_dark_gradient(-400, -250, 500, 400, 20, direction=False)
TravelGate(-600, -250, 60, 400, self.roomid, 'R1_10')

# set room music
stop_track(game.music)
play_track(game.music, 6)
# Empty lines for scroll glitch




","loop":"#1_0 loop

"
}
},
{"R1_1":{
"type":"room script","start":"game.npcs.clear()

game.dark = False

self.roomid = '1-1'

game.cam_limit_x = (-110, 1610)
game.cam_limit_y = (90, -90)

# room IDs and spawn locations for rooms that lead to this room
if game.travelid == '1-0':
    smooth_tp(-500, 50)
elif game.travelid == '1-2':
    smooth_tp(2100, 0)
else:
    smooth_tp(0, 0)


# X is (0, 0)
lvlmap = [
    '    7CCCCCCCCCCCCCCCCCCCC6    ',
    '    L....................R    ',
    'CCCC3....................2CCCC',
    '..............................',
    '.......X.NBVN....VBNB.........',
    'NVBV1.........................',
    '    L....................0VNBB',
    '    L....................R    ',
    '    5VBNVBNNVNBBNVNVNBNBN4    '

]
make_map(lvlmap)


# make colliders
colliders = [
    (750, 400, 2200, 95),
    (950, -400, 2600, 95), 
    (350, 0, 395, 95),
    (1150, 0, 395, 95),
    (-500, 300, 495, 295),
    (-500, -250, 495, 395),
    (2000, 300, 495, 295),
    (2000, -300, 495, 295),

]

blockgroup(0, 0, colliders)

# background configuration
game.bg.sprite = new_sprite(\"purple_bg.png\")
game.bg.x, game.bg.y = 300, 0
game.bg.scaleX = 2
game.bg.scaleY = 2

# create objects
make_current(750, 240, 2000, 220, 0, -8)
make_current(750, -240, 2000, 220, 0, 8)

for xc in range(200, 501, 100):
    make_spike(xc, 90, \"S\")
    make_spike(xc, -90, \"N\")

for xc in range(1000, 1301, 100):
    make_spike(xc, 90, \"S\")
    make_spike(xc, -90, \"N\")

make_booster(0, -300, -90)
make_booster(0, 300, -90)

make_booster(600, -300, -45)
make_booster(600, 300, -135)


# make gradients over exits/entrances
make_dark_gradient(2000, 0, 500, 500, 20)
TravelGate(2220, 0, 60, 500, self.roomid, 'R1_2')

make_dark_gradient(-500, 50, 500, 400, 20, direction=False)
TravelGate(-700, 50, 60, 400, self.roomid, 'R1_0')

# set room music
stop_track(game.music)
play_track(game.music, 1)
# Empty lines for scroll glitch





","loop":"#1_0 loop

"
}
},
{"R1_2":{
"type":"room script","start":"# npc list for player to check
game.npcs.clear()

# whether room is dark
game.dark = False

# ROOM ID - used for determining location when going to other rooms
self.roomid = '1-2'

# lowest(left) x + 640, highest(right) x - 640
game.cam_limit_x = (-110, 1610)
# highest y - 360, lowest y + 360
game.cam_limit_y = (90, -90)

# Insert room IDs and spawn locations for rooms that lead to this room
if game.travelid == '1-1':
    smooth_tp(-500, 50)
elif game.travelid == '1-3':
    smooth_tp(2100, 0)
else:
    smooth_tp(0, 0)


# X is (0, 0)
lvlmap = [
    '    7CCCCCCCCCCCCCCCCCCCC6',
    '    L....................R',
    'CCCC3...O................2CCCC',
    '........O.....................',
    '.......X......................',
    '.........................0VNNB',
    'NNBV1....................R',
    '    L....................R',
    '    5VBNVBNNVNBBNVNVNBNBN4'

]
make_map(lvlmap)


# make colliders
colliders = [
    (750, 400, 2200, 95),
    (950, -400, 2600, 95), 
    (100, 150, 95, 195),
    (-500, 300, 495, 295),
    (-500, -300, 495, 295),
    (2000, 300, 495, 295),
    (2000, -250, 495, 395),

]
blockgroup(0, 0, colliders)

# background configuration
game.bg.sprite = new_sprite(\"purple_bg.png\")
game.bg.x, game.bg.y = 300, 0
game.bg.scaleX = 2
game.bg.scaleY = 2

# room objects
make_current(900, 0, 1800, 700, -19, 0)
make_booster(0, -300, -90)
make_booster(400, -300, -45)
make_booster(400, 0, -90)
make_booster(700, 100, -90)
make_booster(1000, 100, 255)
make_booster(1300, 100, 270)
make_booster(1600, 100, 270)
make_spike(180, 100, \"W\")
make_spike(180, 200, \"W\")

make_dark_gradient(2000, 50, 500, 400, 20)
TravelGate(2200, 50, 60, 400, self.roomid, 'R1_3')

make_dark_gradient(-500, 0, 500, 500, 20, direction=False)
TravelGate(-700, 0, 60, 500, self.roomid, 'R1_1')



# set room music
stop_track(game.music)
play_track(game.music, 1)
# Empty lines for scroll glitch




","loop":"#R1_2 loop

"
}
},
{"R1_3":{
"type":"room script","start":"# npc list for player to check
game.npcs.clear()

# whether room is dark
game.dark = False

# ROOM ID - used for determining location when going to other rooms
self.roomid = '1-3'

# lowest(left) x + 640, highest(right) x - 640
game.cam_limit_x = (290, 1210)
# highest y - 360, lowest y + 360
game.cam_limit_y = (90, -90)

# Insert room IDs and spawn locations for rooms that lead to this room

smooth_tp(-100, 0)



# X is (0, 0)
lvlmap = [
    '7CCCCCCCCCCCCCCCCCCCC6',
    'L......RL.....RL.....R',
    'L......RL.....RL.....R',
    '.......67.....67......',
    '...X..................',
    '.......45.....45......',
    'L......RL.....RL.....R',
    'L......RL.....RL.....R',
    '5VBNVBNNVNBBNVNVNBNBN4'

]
make_map(lvlmap)

# I didn't write this
game.bg.sprite = new_sprite(\"purple_bg.png\")
game.bg.x, game.bg.y = 300, 0
game.bg.scaleX = 2
game.bg.scaleY = 2

# make colliders
colliders = [
    (0, -200, 95, 900),
    (1050, 200, 2200, 95),
    (1250, -600, 2600, 95), 
    (2300, -200, 495, 900),
    (750, 0, 200, 300),
    (750, -400, 200, 300),
    (1450, 0, 200, 300),
    (1450, -400, 200, 300)

]

# from top left
blockgroup(-300, 200, colliders)
make_anglerf(600, 0)
make_anglerf(1200, 0)

# make objects here
# JELLY - x, y, angle, scale=1
# CURRENT - x, y, w, h, xa, ya
# BOOSTER - x, y, angle, force=30
# SFISH - x, y, angle, AI=True
# BOUNCER/(bumper) - x, y, force=30
# ANGLERF - x, y, AI=True
# SPIKE - x, y, point_d, scale=1


# make gradients over exits/entrances
# x, y, w, h, levels, direction=True, vert=False
# levels is number of different opacity rects to divide into
# direction True means top/left is lightest part (for exits going right/down)
# vert decides vertical or horizontal gradient
make_dark_gradient(2000, -250, 500, 400, 20)
#self.gate = TravelGate(2220, -450, 60, 400, self.roomid, 'Room1')


# set room music
stop_track(game.music)
play_track(game.music, 1)
# Empty lines for scroll glitch




","loop":"#R1_3 loop

"
}
},
{"R1_4":{
"type":"room script","start":"#R1_4 start

","loop":"#R1_4 loop

"
}
},
{"R1_5":{
"type":"room script","start":"#R1_5 start

","loop":"#R1_5 loop

"
}
},
{"R1_6":{
"type":"room script","start":"#R1_6 start

","loop":"#R1_6 loop

"
}
},
{"R1_7":{
"type":"room script","start":"#R1_7 start

","loop":"#R1_7 loop

"
}
},
{"R1_8":{
"type":"room script","start":"#R1_8 start

","loop":"#R1_8 loop

"
}
},
{"R1_9":{
"type":"room script","start":"#R1_9 start

","loop":"#R1_9 loop

"
}
},
{"R1_10":{
"type":"room script","start":"game.npcs.clear()
game.dark = False

# ROOM ID - used for determining location when going to other rooms
self.roomid = '1-10'

game.cam_limit_x = (390, 1410)
game.cam_limit_y = (-10, -590)

if game.travelid == '1-9':
    smooth_tp(0, -750)
elif game.travelid == '1-0':
    smooth_tp(1900, -250)
else:
    smooth_tp(0, 0)



# X is (0, 0)
lvlmap = [
    '7CCCCCCCCCCCCCCCCC6',
    'L.................R',
    'L.................R',
    'L.X...............R',
    'L.................2CCCC',
    'L......................',
    'L......................',
    'L.................0VBNN',
    'L...0NNVNBBNVNBNBN4',
    'L...R              ',
    'L...R              ',
    'L...R              ',
    'L...R              ',

]
make_map(lvlmap)

game.bg.sprite = sprite(\"purple_bg.png\")
game.bg.x, game.bg.y = 300, -100
game.bg.scaleX = 2
game.bg.scaleY = 2
game.bg.z = -10

# make colliders
colliders = [
    (900, 0, 1900, 95),
    (0, -600, 95, 1295),
    (1100, -1000, 1495, 495),
    (2000, -750, 495, 195),
    (2000, -200, 495, 495),


]
# from top left
blockgroup(-200, 300, colliders)

make_current(700, -100, 1700, 700, 20, 0)

make_dark_gradient(1800, -250, 500, 400, 20)
TravelGate(2000, -250, 60, 400, self.roomid, 'R1_0')

make_dark_gradient(0, -700, 500, 500, 20, vert=True)
TravelGate(0, -900, 500, 60, self.roomid, 'R1_9')

# set room music
stop_track(game.music)
play_track(game.music, 6)
# Empty lines for scroll glitch




","loop":"#R1_10 loop

"
}
}
]
},
{"Stage2":[
{"R2_0":{
"type":"room script","start":"#R2_0 start

","loop":"#R2_0 loop

"
}
},
{"R2_1":{
"type":"room script","start":"#R2_1 start

","loop":"#R2_1 loop

"
}
},
{"R2_2":{
"type":"room script","start":"#R2_2 start

","loop":"#R2_2 loop

"
}
},
{"R2_3":{
"type":"room script","start":"#R2_3 start

","loop":"#R2_3 loop

"
}
},
{"R2_4":{
"type":"room script","start":"#R2_4 start

","loop":"#R2_4 loop

"
}
},
{"R2_5":{
"type":"room script","start":"#R2_5 start

","loop":"#R2_5 loop

"
}
},
{"R2_6":{
"type":"room script","start":"#R2_6 start

","loop":"#R2_6 loop

"
}
},
{"R2_7":{
"type":"room script","start":"#R2_7 start

","loop":"#R2_7 loop

"
}
},
{"R2_8":{
"type":"room script","start":"#R2_8 start

","loop":"#R2_8 loop

"
}
},
{"R3_B":{
"type":"room script","start":"# npc list for player to check
game.npcs.clear()

# whether room is dark
game.dark = False

# ROOM ID - used for determining location when going to other rooms
self.roomid = '3-B'

# lowest(left) x + 640, highest(right) x - 640
game.cam_limit_x = (490, 1510)
# highest y - 360, lowest y + 360
game.cam_limit_y = (-210, -790)

# Insert room IDs and spawn locations for rooms that lead to this room

smooth_tp(1900, -500)



# X is (0, 0)
lvlmap = [
    '7CCCCCCCCCCCCCCCCCCCCC6',
    'LX....................R',
    'L.....................R',
    'L.....................R',
    'L.....................R',
    'L......................',
    'L......................',
    'L......................',
    'L.....................R',
    'L.....................R',
    'L.....................R',
    'L.....................R',
    '5VBNVBNNVNBBNVNVNBNBNN4'

]
make_map(lvlmap)

# I didn't write this
game.bg.sprite = new_sprite(\"purple_bg.png\")
game.bg.x, game.bg.y = 500, -100
game.bg.scaleX = 2
game.bg.scaleY = 1.5

# make colliders
colliders = [
    (1000, 100, 2300, 100),
    (1000, -1100, 2300, 100),
    (-100, -500, 100, 1300),
    (2100, -100, 100, 500),
    (2100, -900, 100, 500)

]

# from top left
blockgroup(0, 0, colliders)

# make objects here
make_current(1800, -500, 500, 1100, -25, 0)
# JELLY - x, y, angle, scale=1
# CURRENT - x, y, w, h, xa, ya
# BOOSTER - x, y, angle, force=30
# SFISH - x, y, angle, AI=True
# BOUNCER/(bumper) - x, y, force=30
# ANGLERF - x, y, AI=True
# SPIKE - x, y, point_d, scale=1


# make gradients over exits/entrances
# x, y, w, h, levels, direction=True, vert=False
# levels is number of different opacity rects to divide into
# direction True means top/left is lightest part (for exits going right/down)
# vert decides vertical or horizontal gradient

#self.gate = TravelGate(2220, -450, 60, 400, self.roomid, 'Room1')


# set room music
stop_track(game.music)
play_track(game.music, 6)
# Empty lines for scroll glitch




","loop":"#R3_B loop

"
}
}
]
},
{"Room_Template":{
"type":"room script","start":"# npc list for player to check
game.npcs.clear()

# whether room is dark
game.dark = False

# ROOM ID - used for determining location when going to other rooms
self.roomid = '69-69'

# lowest(left) x + 640, highest(right) x - 640
game.cam_limit_x = (290, 1610)
# highest y - 360, lowest y + 360
game.cam_limit_y = (-110, -290)

# Insert room IDs and spawn locations for rooms that lead to this room
if game.travelid == '1-0':
    smooth_tp(-350, -50)
else:
    smooth_tp(0, 0)


# X is (0, 0)
lvlmap = [
    '7CCCCCCCCCCCCCCCCCCCC6',
    'L....................R',
    'L..X.................R',
    'L....................R',
    'L....................R',
    'L....................2CCCC',
    'L.........................',
    'L.........................',
    '5VBNVBNNVNBBNVNVNBNBNVBNVN'

]
make_map(lvlmap)

# background manipulation
game.bg.sprite = new_sprite(\"purple_bg.png\")
game.bg.x, game.bg.y = -100, -300
game.bg.scaleX = 2
game.bg.scaleY = 1.5

# make colliders
colliders = [
    (0, -400, 95, 900),
    (1050, 0, 2200, 95),
    (1250, -800, 2600, 95), 
    (2300, -250, 495, 595),

]

# from top left
blockgroup(-300, 200, colliders)

# make objects here
# JELLY - x, y, angle, scale=1
# CURRENT - x, y, w, h, xa, ya
# BOOSTER - x, y, angle, force=30
# SFISH - x, y, angle, AI=True
# BOUNCER/(bumper) - x, y, force=30
# ANGLERF - x, y, AI=True
# SPIKE - x, y, point_d, scale=1

# make gradients over exits/entrances
# x, y, w, h, levels, direction=True, vert=False
# levels is number of different opacity rects to divide into
# direction True means top/left is lightest part (for exits going right/down)
# vert decides vertical or horizontal gradient
make_dark_gradient(2000, -450, 500, 400, 20)
self.gate = TravelGate(2220, -450, 60, 400, self.roomid, 'Room1')


# set room music
stop_track(game.music)
play_track(game.music, 6)
# Empty lines for scroll glitch




","loop":"#Room_Template loop

"
}
}
],
"texture":[
{"tiles":[
{"ground1.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615954594.ground1.png"
}
},
{"ground2.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615954601.ground2.png"
}
},
{"ground3.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616115967.ground3.png"
}
},
{"ciel.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616116213.ciel.png"
}
},
{"wall_left.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616115833.wall_left.png"
}
},
{"wall_right.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615954627.wall_right.png"
}
},
{"in_corner_tl.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616112361.in_corner_tl.png"
}
},
{"in_corner_tr.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616112366.in_corner_tr.png"
}
},
{"in_corner_bl.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616112369.in_corner_bl.png"
}
},
{"in_corner_br.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616112375.in_corner_br.png"
}
},
{"out_corner_tl.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616116555.out_corner_tl.png"
}
},
{"out_corner_tr.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616116613.out_corner_tr.png"
}
},
{"out_corner_bl.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616116633.out_corner_bl.png"
}
},
{"out_corner_br.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616116652.out_corner_br.png"
}
},
{"centre.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616570454.centre.png"
}
},
{"dark_tile.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616445786.dark_tile.png"
}
}
]
},
{"NPCs":[
{"whalesheet_gap.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615951543.whalesheet_gap.png"
}
}
]
},
{"Player":[
{"dynamic_squid.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615957753.dynamic_squid.png"
}
},
{"player_still.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616453331.player_still.png"
}
}
]
},
{"Stage1":[
{"Tiles1":[

]
},
{"Background1":[
{"gradient1.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615953211.gradient1.png"
}
},
{"purple_bg.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616546270.purple_bg.png"
}
},
{"pixel_bg_stage1.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615960001.pixel_bg_stage1.png"
}
}
]
}
]
},
{"Stage2":[
{"Tiles2":[

]
},
{"Background2":[
{"waterBG.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.225782.1615667719.waterBG.png"
}
}
]
}
]
},
{"Gameplay_elements":[
{"boostersheet.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616545842.boostersheet.png"
}
},
{"bouncesheet.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616545187.bouncesheet.png"
}
},
{"sonar_beam.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616371496.sonar_beam.png"
}
},
{"Spike1.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225969.1616188359.Spike1.png"
}
},
{"Spike1_dark.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616456779.Spike1_dark.png"
}
},
{"Spike2.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225969.1616188331.Spike2.png"
}
}
]
},
{"Misc":[
{"text_box.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616039356.text_box.png"
}
},
{"black40x40.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616018445.black40x40.png"
}
},
{"debug.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1615942085.debug.png"
}
},
{"Guide.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1616348073.Guide.png"
}
},
{"current_particle.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1616545915.current_particle.png"
}
},
{"current_particle_dark.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616456872.current_particle_dark.png"
}
}
]
},
{"Enemies":[
{"Swordfish.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616455645.Swordfish.png"
}
},
{"Swordfish_dark.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616456827.Swordfish_dark.png"
}
},
{"jelly.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616347498.jelly.png"
}
},
{"jelly_dark.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616456808.jelly_dark.png"
}
},
{"Anglerfish_light.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616275209.Anglerfish_light.png"
}
},
{"Anglerfish.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616275637.Anglerfish.png"
}
},
{"Anglerfish_dark.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616454910.Anglerfish_dark.png"
}
}
]
},
{"Tutorial":[
{"newE.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616348829.newE.png"
}
},
{"pressE.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616288773.pressE.png"
}
}
]
},
{"Boss":[
{"Boss_Spike.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1616560041.Boss_Spike.png"
}
}
]
},
{"Health":[
{"health_0.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616393393.health_0.png"
}
},
{"health_1.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616393407.health_1.png"
}
},
{"health_2.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616393414.health_2.png"
}
},
{"health_3.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616393422.health_3.png"
}
},
{"health_4.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616393430.health_4.png"
}
},
{"health_5.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616393438.health_5.png"
}
}
]
}
],
"sound":[
{"Mood1.mp3":{
"type":"audio","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1616368556.Mood1.mp3"
}
},
{"Mood2.mp3":{
"type":"audio","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1616368566.Mood2.mp3"
}
},
{"Mood3.mp3":{
"type":"audio","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1616368576.Mood3.mp3"
}
},
{"Mood4.mp3":{
"type":"audio","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1616368585.Mood4.mp3"
}
},
{"Mood5.mp3":{
"type":"audio","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1616368596.Mood5.mp3"
}
},
{"Mood6.mp3":{
"type":"audio","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1616368609.Mood6.mp3"
}
},
{"Mood7.mp3":{
"type":"audio","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1616368620.Mood7.mp3"
}
},
{"Mood8.mp3":{
"type":"audio","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1616368629.Mood8.mp3"
}
}
],
"function":[
{"imports.py":{
"type":"function script","head":"#File for imports to run before everything
import math
import time
import random"
}
},
{"gamefuncs.py":{
"type":"function script","head":"#A collection of helper functions/enums.


def hyp(s, c) -> int:
    \"\"\"Return hypotenuse of right angle triangle.\"\"\"
    return math.sqrt((s**2)+(c**2))

def get_angle(y) -> float:
    \"\"\"Return angle of right angle triangle.
    
    Assumes hypotenuse is 1
    \"\"\"
    return math.degrees(math.asin(y))

def deter(val, k) -> int:
    \"\"\"Helper function that allows for movement deterioration
    while preventing rounding errors.\"\"\"
    if abs(val) <= 0.1: return 0
    return round(val*k, 3)

def get_dist(x1, y1, x2, y2):
    \"\"\"Return the distance between two points.\"\"\"
    return math.sqrt((x2-x1)**2 + (y2-y1)**2)

def do_move(pl, xdist, ydist):
    # Increase velocity
    pl.xv += (xdist*0.9)
    pl.yv += (ydist*0.9)
    
    # Get total velocity magnetude
    Vhyp = hyp(pl.xv, pl.yv)
    
    # Correct velocity speed
    if Vhyp > 6.5: # 6.5
        pl.xv = (pl.xv/Vhyp)*6.5
        pl.yv = (pl.yv/Vhyp)*6.5

def update_spr(plspr, x, y, angle):
    plspr.x = x
    plspr.y = y
    plspr.angle = angle

def angle_helper(Dx, Dy) -> int:
    \"\"\"This function returns the angle for an object moving in a specific direction.\"\"\"
    if not Dx and not Dy: Dx = 1
    m = hyp(Dx, Dy)
    Dy = Dy/m

    if m > 1:
        a = get_angle(Dy) - 90
        return a if Dx > 0 else -a
    
    return -361

def time_ms():
    return round(time.time() * 1000)

def boost(pl, force, angle):
    pl.xv = 0
    pl.yv = 0
    pl.boostx = 0
    pl.boosty = 0
    pl.xMOD += force * math.cos(math.radians(angle+90))
    pl.yMOD += force * math.sin(math.radians(angle+90))

def smooth_tp(x, y):
    \"\"\"Teleport the player to x and y and manage camera movement.\"\"\"

    offset_x = game.p.x - camera_x()
    offset_y = game.p.y - camera_y()
    game.p.x = x
    game.p.y = y

    new_camX = x + offset_x
    new_camY = y + offset_y
    new_camX = min(max(new_camX, game.cam_limit_x[0
]), game.cam_limit_x[1
])
    new_camY = max(min(new_camY, game.cam_limit_y[0
]), game.cam_limit_y[1
])
    set_camera(new_camX, new_camY)

def damage(st):
    if game.p.dmgF:
        game.p.hp -= st
        game.p.spr_obj.alpha = 0.6
        game.p.dmgF = False
        game.p.damage_cool = game.t + 600
        

def transform(obj, x, y, scaleX=None, scaleY=None):
    \"\"\"Simple transform helper for working with slates.\"\"\"
    obj.x = x
    obj.y = y
    if scaleX: obj.scaleX = scaleX
    if scaleY: obj.scaleY = scaleY

def hitbox_rotate(obj, orig, obj_0, rad):
    \"\"\"For rotating objects around a point.\"\"\"
    obj.x = (math.cos(math.radians(obj_0)) * rad) + orig.x
    obj.y = (math.sin(math.radians(obj_0)) * rad) + orig.y

def create_e(obj):
    # clear any current \"E\"s
    try:
        destroy(game.e)
    # no text box currently up
    except AttributeError:
        pass
    game.e = Slate()
    game.e.sprite = sprite('newE.png')
    game.e.scaleX = game.e.scaleY = 0.3
    game.e.x = obj.x
    game.e.y = obj.y + obj.e_offset
    obj.e_popup = True

def create_msg(obj):
    try:
        destroy(game.e)
    # no text box currently up
    except AttributeError:
        pass
    TextBox(obj.msg, obj.msg_duration)

def play_track(s_obj, s_id):
    s_obj.song = new_sound(\"Mood\" + str(s_id) + \".mp3\")
    set_volume(s_obj.song, 0.3)
    loop_sound(s_obj.song)

def stop_track(s_obj):
    if s_obj.song != None:
        stop_sound(s_obj.song)
        s_obj.song = None

"
}
},
{"make_map.py":{
"type":"function script","head":"tile_map = {
    'C': (sprite('ciel.png'), ),
    'L': (sprite('wall_left.png'), ),
    'R': (sprite('wall_right.png'), ),
    'V': (sprite('ground1.png'), ),
    'B': (sprite('ground2.png'), ),
    'N': (sprite('ground3.png'), ),
    '0': (sprite('in_corner_tl.png'), ),
    '1': (sprite('in_corner_tr.png'), ),
    '2': (sprite('in_corner_bl.png'), ),
    '3': (sprite('in_corner_br.png'), ),
    '4': (sprite('out_corner_tl.png'), ),
    '5': (sprite('out_corner_tr.png'), ),
    '6': (sprite('out_corner_bl.png'), ),
    '7': (sprite('out_corner_br.png'), ),
    \"O\": (sprite(\"centre.png\"), ),
    \"~\": (sprite(\"black40x40.png\"), 2.5, 2.5, 0, 0, -5),

}
DARK_TILE = sprite('dark_tile.png')

def make_map(layout):
    for i in range(len(layout)):
        if 'X' in layout[i
]:
            origin = (layout[i
].index('X'), i)
    
    for i in range(len(layout)):
        for j in range(len(layout[i
])):
            key = layout[i
][j
]
            if key in '. X':
                continue
            elif key not in tile_map.keys():
                print(f'Unrecognised \"{layout[i
][j
]
} in level map.')
                continue

            t = Tile()

            t.x = 100 * (j - origin[0
])
            t.y = 100 * (origin[1
] - i)
            t.z = 9
            if len(tile_map[key
]) == 1:
                t.sprite = DARK_TILE if game.dark else tile_map[key
][0
]
            else:
                spr, scX, scY, x_off, y_off, z = tile_map[key
]
                t.sprite = spr
                t.scaleX = scX
                t.scaleY = scY
                t.x += x_off
                t.y -= y_off
                t.z = z







"
}
},
{"gamecreation.py":{
"type":"function script","head":"

d_to_angle = {
    \"N\": 0,
    \"W\": 90,
    \"S\": 180,
    \"E\": 270

}

def createblock(x, y, w, h):
    \"\"\"Basic opaque block. Takes args for pos, size, and optional block sprite.\"\"\"
    #construct block and set args
    a = Block()
    a.x = x
    a.y = y
    #This works for 40x40 sprite. For other sprites, change divisor accordingly
    a.sprite = sprite('debug.png') if game.debug else sprite('black40x40.png')
    a.scaleX = w/40
    a.scaleY = h/40
    
    if game.debug:
        a.alpha = 0.6
    else:
        a.z = -5

    #store these for collision purposes
    a.wid = w/2
    a.ht = h/2
    a.nf = y+a.ht
    a.sf = y-a.ht
    a.wf = x-a.wid
    a.ef = x+a.wid
    
    return a

def blockgroup(x, y, posl):
    \"\"\"Creates a group of blocks at a x and y position,
    given a list  of block constructs. posl is a list of tuples,
    each of the form (x, y, w, h).\"\"\"
    for bx, by, bw, bh in posl:
        createblock(bx+x, by+y, bw, bh)

def make_current(x, y, w, h, xa, ya):
    \"\"\"Create a current block, which takes arguments for
    position, size, and acceleration values.\"\"\"
    inst = Current()
    inst.x = x
    inst.y = y
    inst.scaleX = w/40
    inst.scaleY = h/40
    inst.xa = xa
    inst.ya = ya

    inst.w = w/2
    inst.h = h/2
    inst.dense = max((w*h)//20000, 1)
    return inst
    
def make_particle(x, y, xv, yv, spr, proc):
    \"\"\"Create a particle with a linear velocity. 
    Pass in a parent process that will kill the particle later.\"\"\"
    inst =  Particle()
    inst.x = x
    inst.y = y
    inst.sprite = new_sprite(spr)
    inst.xv = xv
    inst.yv = yv
    inst.parent = proc
    inst.nb = proc.y + proc.h
    inst.sb = proc.y - proc.h
    inst.eb = proc.x + proc.w
    inst.wb = proc.x - proc.w
    inst.angle = angle_helper(xv, yv) + 90

def make_booster(x, y, angle, force=30):
    \"\"\"A booster that launches you at a certain angle when touched.
    Force is given a default value, as for the sake of gameplay, faster boosters should
    be indicated as such to the player.\"\"\"
    inst = Booster()
    inst.x = inst.disp.x = x
    inst.y = inst.disp.y = y
    inst.angle = inst.disp.angle = angle
    inst.force = force

def make_bumper(x, y, force=30):
    \"\"\"A bumper that always sends you in the opposite direction 
    from when you last bumped into it.\"\"\"
    inst = Bumper()
    inst.x = inst.disp.x = x
    inst.y = inst.disp.y = y
    inst.force = force

def make_spike(x, y, point_d, scale=1):
    \"\"\"Make a spike at specified coords as well as a direction
    (N, S, E, W). Also takes optional arg for scale.\"\"\"
    inst = Spike()
    inst.x = x
    inst.y = y
    inst.angle = d_to_angle[point_d
]
    inst.scaleX *= scale
    inst.scaleY *= scale

def make_anglerf(x, y, AI=True):
    \"\"\"Create an anglerfish.\"\"\"
    inst = Anglerfish()
    inst.x = x
    inst.y = y
    
def make_hurtbox(x, y, w, h, dmg, boost_f=None):
    \"\"\"Create a hurtbox at a specific location, given dimenstions,
    damage value, and a player movement modification function\"\"\"
    inst = Hurtbox()
    inst.x = x
    inst.y = y
    
    inst.scaleX = w/40
    inst.scaleY = h/40
    inst.dmg = dmg
    if boost_f != None:
        inst.func = boost_f
    return inst

def make_jelly(x, y, angle, scale=1):
    \"\"\"Create a jellyfish pointing at a specfic angle.\"\"\"
    inst = Jellyfish()
    inst.x = x
    inst.y = y
    inst.angle = angle
    inst.scaleX *= scale
    inst.scaleY *= scale
    inst.bounce_h.x = x + math.cos(math.radians(angle+90))*20
    inst.bounce_h.y = y + math.sin(math.radians(angle+90))*20
    inst.bounce_h.angle = angle
    inst.bounce_h.scaleX *= scale
    inst.bounce_h.scaleY *= scale    
    inst.hbox = make_hurtbox(x, y+20, 40*scale, 30*scale, 1)
    hitbox_rotate(inst.hbox, inst, angle-90, 20)
    inst.hbox.angle = angle

def make_sfish(x, y, angle, AI=True):

    inst = Swordfish()
    inst.x = x
    inst.y = y
    inst.angle = angle
    inst.ai = AI
    hitbox_rotate(inst.h, inst, inst.angle, 40)
    inst.h.angle = angle
    if 90<angle<=270:
        inst.scaleY *= -1

    return inst

def make_echo(x, y, angle):
    e = Echolocation()
    e.x = x
    e.y = y
    e.angle = angle
    e.xvel = math.cos(math.radians(angle+90))*14
    e.yvel = math.sin(math.radians(angle+90))*14

"
}
},
{"make_dark_gradient.py":{
"type":"function script","head":"def make_dark_gradient(x, y, w, h, levels, direction=True, vert=False, over=True):
    \"\"\"Make a fade to black gradient centered around x, y of width
    w and height h.
    
    Arg \"levels\" specifies the number of steps to divide the gradient into
    Arg \"direction\" is True if top/left should be the lightest part
    Arg \"vert\" is True if gradient should be vertical
    Arg \"over\" decides if the gradient should go over the player
    \"\"\"
    
    width = w/levels if not vert else w
    height = h/levels if vert else h

    for i in range(levels):
        t = Slate()
        t.sprite = sprite('debug.png') if game.debug else sprite('black40x40.png')
        t.scaleX = (width/40)
        t.scaleY = (height/40)
        
        if vert:
            t.x = x 
            t.y = ((y + (h/2)) - (height/2)) - (height * i)
        else:
            t.x = (x - (w/2) + (width/2)) + (width * i)
            t.y = y

        t.alpha = (1/(levels-1)) * i if direction else 1 - ((1/(levels-1)) * i)

        if over: t.z = 24"
}
},
{"Nautilusfuncs.py":{
"type":"function script","head":"def summon_spike(boss):
    \"\"\"Summons spikes around the boss, which
    then home towards the player.\"\"\"
    x0, y0 = boss.x, boss.y
    offset0 = random.randrange(0, 60)

    for i in range(6):
        inst = boss_spike()
        inst.angle = (i*60) + offset0
        gcos, gsin = math.cos(math.radians(self.angle)), math.sin(math.radians(self.angle))
        inst.x = 100*gcos
        inst.y = 100*gsin
        
def summon_swordfish(boss):
    \"\"\"Summons swordfish.\"\"\"
    origin = boss.x
    t = random.choice([\"T, B\"
])
    if t == \"T\":
        sy = 0
        sa = -90
    else:
        sy = 1000
        sa = 90

    for i in range(1, 5):
        k = make_sfish(origin + (i*100), sy, sa)
        k.fading = True

def shockwave(boss):
    \"\"\"Makes shockwave and sends player flying with massive current.\"\"\"
    x0, y0 = boss.x, boss.y
    hb = make_hurtbox(x0, y0, 400, 400, 1)
    hb.temp = True
    hb.exp_time = game.t + 400
    cur = make_current(-500, 700, 1400, 1000, 23, 0)
    cur.temp = True
    cur.exp_time = game.t + 1200

def dash(boss):
    \"\"\"Dash towards the player, dealing large damage.\"\"\"

        
        

"
}
},
{"Classes":[
{"TravelGate.py":{
"type":"function script","head":"class TravelGate:
    def __init__(self, x, y, w, h, roomid, dest):
        self.inst = travelgate_inst()
        self.inst.parent = self
        self.inst.x = x
        self.inst.y = y
        
        self.inst.sprite = sprite('debug.png') if game.debug else sprite('black40x40.png')
        self.inst.visible = game.debug
        self.inst.scaleX = w/40
        self.inst.scaleY = h/40

        self.roomid = roomid
        self.dest = dest

    def travel(self):
        \"\"\"\"\"\"
        game.travelid = self.roomid
        set_room(self.dest)"
}
},
{"TextBox.py":{
"type":"function script","head":"class TextBox:
    def __init__(self, msg, duration):
        \"\"\"Create a textbox with msg text that last for a 
        minimum of duration ms.\"\"\"\"

        try: # clear possible current text box
            game.text_box.destroy()
        except Exception as e: # no text box currently up
            print('Exception caught:', e)

        self.inst = textbox_inst()
        self.inst.parent = self
        self.inst.x = camera_x()
        self.inst.y = camera_y() - 200
        game.text_box = self
        
        self.text = text(msg, self.inst.x - 450, self.inst.y + 40)
        self.text.color = '#ffffff'
        self.text.fontsize = 70
        self.text.fontFamily = 'courier new'
        self.inst.z = 25
        self.text.z = 25

        self.close_time = game.t + duration
        self.textexists = True
    
    def do_loop(self):
        
        try:
            self.text.x 
        except Exception:
            self.textexists = False
        
        self.inst.x = camera_x()
        self.inst.y = camera_y() - 200
        
        if self.textexists:
            self.text.x = self.inst.x - 450
            self.text.y = self.inst.y + 40
        

        if game.t > self.close_time:
            keys = (
                mouse_is_pressed('left'),
                mouse_is_pressed('right'),
                key_is_pressed('arrowRight'),
                key_is_pressed('arrowLeft'),
                key_is_pressed('arrowDown'),
                key_is_pressed('arrowUp'),
                key_is_pressed(' ')
            )

            if any(keys):
                self.destroy()
        
    def destroy(self):
        destroy(self.inst)
        destroy(self.text)
    


"
}
},
{"NPC.py":{
"type":"function script","head":"
def make_simple_npc(x, y, type_, msg, scale=1):
    \"\"\"Create a simple npc with only one line.\"\"\"

    type_map = {
        'Whale': Whale
    
}

    n = type_map[type_
]()
    n.x = x
    n.y = y
    n.scaleX *= scale
    n.scaleY *= scale
    n.e_offset *= scale
    n.msg = msg
    n.msg_duration = 1200
    
    # flag for if \"e to interact\" popup is up
    n.e_popup = False

    game.npcs.append(n)
    return n"
}
},
{"ProgTracker.py":{
"type":"function script","head":"class ProgTracker:
    def __init__(self):
        
        self.move = False # Movement tutorial
        self.interact = False # Interaction tutorial"
}
}
]
}
]
}
}