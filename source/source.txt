{"assets":{
"script":[
{"Game":{
"type":"game script","start":"self.bg = Background()\r
level = [\r
        '...CCC...',\r
        '..3L.R3..',\r
        '...L.R...',\r
        '...L.R...',\r
        '...L.R...',\r
        '...L.R...',\r
        '...LXR...',\r
        '...L.R...',\r
        '.2CC.CC2.',\r
        '.L.....R.',\r
        '.1232131.'
]\r
make_map(level)\r
\r
w = Whale()\r
self.p = Player()\r
\r
bigwhale = Whale()\r
bigwhale.scaleX = bigwhale.scaleY = 3.5\r
bigwhale.x = bigwhale.y = -700\r
\r
self.fpslog = int(time.time())\r
self.fpscount = 0\r
\r
createblock(400, 400, 200, 200)\r
\r
set_room('Starting_Room')","loop":"self.fpscount += 1\r
ntime = int(time.time())\r
\r
if ntime > self.fpslog:\r
    self.fpslog = ntime\r
    print(f\"Frames elapsed in last second: {self.fpscount
}\")\r
    self.fpscount = 0"
}
},
{"Player":{
"type":"object script","start":"# initialise pos, sprite
self.x = 0
self.y = 0
#self.z = 1000
self.sprite = new_sprite(\"debug.png\")

self.persistent = True

# velocity values
self.xv = 0
self.yv = 0
self.boostx, self.boosty = 0, 0

self.y_off = 0
self.x_off = 0

# store previous values
self.x0 = 0
self.y0 = 0

self.spr_obg = Psprite()

# remove for hitbox debug
self.visible = False

self.scaleX = 2
self.scaleY = 2","loop":"camX, camY = camera_x(), camera_y()
xdist = (mouse_x()+camX) - self.x
ydist = (mouse_y()+camY) - self.y

# for arrow key movement
keys = [key_is_pressed('arrowRight'), 
        key_is_pressed('arrowLeft'), 
        key_is_pressed('arrowUp'),
        key_is_pressed('arrowDown')
]

# store previous position for movement rotation
self.x0, self.y0 = self.x, self.y

# prevent 0 trig errors
if not xdist and not ydist:
    xdist = 1

# get hypotenuse and adjust x & y for hyp of length 1
magn = hyp(xdist, ydist)
xdist, ydist = xdist/magn, ydist/magn


# move unless mouse is right on top of player
if mouse_is_pressed('left') and not magn < 25:
    do_move(self, xdist, ydist)

# allow for arrow-key movement
elif any(keys):
    xdist=ydist=0
    if keys[0
]: xdist = 1
    if keys[1
]: xdist = -1
    if keys[2
]: ydist = 1
    if keys[3
]: ydist = -1
    magn = hyp(xdist, ydist)
    xdist, ydist = xdist/magn, ydist/magn

    do_move(self, xdist, ydist)

else:
    # \"water resistance\" deteriorate velocity
    self.xv = deter(self.xv, 0.95)
    self.yv = deter(self.yv, 0.95)
    
# dash
if key_was_pressed(' ') or mouse_was_pressed('right'):
    self.boostx = xdist*13
    self.boosty = ydist*13

# deteriorate boost velocity
self.boostx, self.boosty = deter(self.boostx, 0.94), deter(self.boosty, 0.94)

# final movement values in x and y
a, b = (self.xv+self.boostx), (self.yv+self.boosty)

self.x += a
self.y += b


# distance from zero after move
xdist = self.x - camX
ydist = self.y - camY

# control camera offset with WASD
# probably not permanent, just a demonstration of how camera can be offset
if key_is_pressed('d'):
    self.x_off = min(self.x_off+1, 18)
if key_is_pressed('a'):
    self.x_off = max(self.x_off-1, -18)
if key_is_pressed('w'):
    self.y_off = min(self.y_off+1, 16)
if key_is_pressed('s'):
    self.y_off = max(self.y_off-1, -16)

move_camera((xdist - xdist/1.1) + self.x_off,
            (ydist - ydist/1.1) + self.y_off)


# rotate in direction of movement
Dx, Dy = self.x-self.x0, self.y-self.y0
if not Dx and not Dy: Dx = 1
m = hyp(Dx, Dy)
Dy = Dy/m

if m > 1:
    a = get_angle(Dy) - 90
    self.angle = a if Dx > 0 else -a

update_spr(self.spr_obg, self.x, self.y, self.angle)






# Empty lines because I don't like it when code 
# is at the bottom of the screen"
}
},
{"Background":{
"type":"object script","start":"#Background start

self.sprite = sprite('waterBG.png')","loop":"#Background loop

"
}
},
{"Whale":{
"type":"object script","start":"sprite_sheet = sprite('whalesheet_gap.png', 1, 4)
self.anim = animation(sprite_sheet, 4, 0, 3)
set_animation(self, self.anim)
self.scaleX = self.scaleY = 2

#self.sprite = sprite('whale.png')

self.x, self.y = 1500, -420
self.visible = True

self.frames = 0","loop":"try:
    # Exit the loop early if far from player
    pdist = get_dist(self.x, self.y, game.p.x, game.p.y)
    if pdist > 1700:
        if self.visible:
            self.visible = False
        return
    else:
        if not self.visible:
            self.visible = True
except AttributeError: # Whale created before player in Game start
    pass

if self.visible:
    d = self.frames % 100
    
    if 0 <= d < 50:
        self.y += 0.5
    if 50 <= d < 100:
        self.y -= 0.5
    
    self.frames += 1"
}
},
{"Tile":{
"type":"object script","start":"# Empty (at least for now) class that is used to make tiles\r
# Sprite gets set anyways","loop":""
}
},
{"Block":{
"type":"object script","start":"#Block start

","loop":"
# Exit the loop early if far from player
pdistx = self.x - game.p.x
pdisty = self.y - game.p.y


if abs(pdistx) > 2200 or abs(pdisty) > 1600:
    self.visible = False
    return


if self.debug:
    self.visible = True

pl = get_collision(self, \"Player\")
if pl:
    p_nf, p_sf, p_wf, p_ef = pl.y0+40, pl.y0-40, pl.x0-40, pl.x0+40

    if p_nf < self.sf or p_sf > self.nf:
        pl.y = pl.y0

    elif p_ef < self.wf or p_wf >= self.ef:
        pl.x = pl.x0
    
    # \"friction\" slowdown while colliding
    pl.xv = deter(pl.xv, 0.84)
    pl.yv = deter(pl.yv, 0.84)"
}
},
{"Psprite":{
"type":"object script","start":"#Hitbox start
self.z = 1000
self.scaleX = 1
self.scaleY = 1

self.sprite = new_sprite(\"octopus.png\")
spritesheet = sprite('dynamic_squid.png', 4, 4)
self.anim = animation(spritesheet, 8, 0, 12)
set_animation(self, self.anim)

self.persistent = True","loop":"#Psprite loop

"
}
}
],
"room":[
{"Menu":{
"type":"room script","start":"#Menu start

","loop":"#Menu loop

"
}
},
{"Stage1":[
{"Starting_Room":{
"type":"room script","start":"#Starting_Room start

# game.bg = Background()
# game.bg.sprite = sprite('gradient1.png')

colliders = [
    (0, -400, 95, 900),
    (1050, 0, 2200, 95),
    (1250, -800, 2600, 95),
    (2100, -200, 95, 500),
    (2350, -500, 350, 95),

]

# From top left
blockgroup(-300, 200, colliders)

lvlmap = [
    '.CCCCCCCCCCCCCCCCCCCC',
    'L....................R',
    'L..X.................R',
    'L....................R',
    'L....................R',
    'L....................TCCCC',
    'L........................',
    'L........................',
    '.3231332223132311323131321'

]

make_map(lvlmap)","loop":"#Starting_Room loop

"
}
},
{"Room1":{
"type":"room script","start":"#Room1 start

","loop":"#Room1 loop

"
}
}
]
},
{"Stage3":[

]
},
{"Stage2":[

]
}
],
"texture":[
{"tempTiles":[
{"ground1.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615954594.ground1.png"
}
},
{"ground2.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615954601.ground2.png"
}
},
{"ground3.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615954609.ground3.png"
}
},
{"wall_right.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615954627.wall_right.png"
}
},
{"wall_left.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615954929.wall_left.png"
}
},
{"ciel.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615954637.ciel.png"
}
},
{"topright_inside.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615955449.topright_inside.png"
}
}
]
},
{"NPCs":[
{"whalesheet.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615951193.whalesheet.png"
}
},
{"whalesheet_gap.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615951543.whalesheet_gap.png"
}
},
{"whale.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.225782.1615757396.whale.png"
}
}
]
},
{"Player":[
{"octopus.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.225782.1615621603.octopus.png"
}
},
{"dynamic_squid.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615957753.dynamic_squid.png"
}
}
]
},
{"Stage1":[
{"Tiles1":[

]
},
{"Background1":[
{"gradient1.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615953211.gradient1.png"
}
},
{"pixel_bg_stage1.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615960001.pixel_bg_stage1.png"
}
}
]
}
]
},
{"Stage2":[
{"Tiles2":[

]
},
{"Background2":[
{"waterBG.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.225782.1615667719.waterBG.png"
}
}
]
}
]
},
{"Stage3":[
{"Tiles3":[

]
},
{"Background3":[

]
}
]
},
{"debug.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1615942085.debug.png"
}
}
],
"sound":[

],
"function":[
{"imports.py":{
"type":"function script","head":"#File for imports to run before everything
import math
import time
import random

"
}
},
{"quickfuncs.py":{
"type":"function script","head":"#A collection of helper functions/enums.


def hyp(s, c) -> int:
    \"\"\"Return hypotenuse of right angle triangle.\"\"\"
    return math.sqrt((s**2)+(c**2))

def get_angle(y) -> float:
    \"\"\"Return angle of right angle triangle.
    
    Assumes hypotenuse is 1
    \"\"\"
    return math.degrees(math.asin(y))

def deter(val, k) -> int:
    \"\"\"Helper function that allows for movement deterioration
    while preventing rounding errors.\"\"\"
    if abs(val) <= 0.1: return 0
    return round(val*k, 3)

def get_dist(x1, y1, x2, y2):
    \"\"\"Return the distance between two points.\"\"\"
    return math.sqrt((x2-x1)**2 + (y2-y1)**2)

def do_move(pl, xdist, ydist):
    # Increase velocity
    pl.xv += (xdist*0.9)
    pl.yv += (ydist*0.9)
    
    # Get total velocity magnetude
    Vhyp = hyp(pl.xv, pl.yv)
    
    # Correct velocity speed
    if Vhyp > 6.5: # 6.5
        pl.xv = (pl.xv/Vhyp)*6.5
        pl.yv = (pl.yv/Vhyp)*6.5

def update_spr(plspr, x, y, angle):
    plspr.x = x
    plspr.y = y
    plspr.angle = angle"
}
},
{"make_map.py":{
"type":"function script","head":"tile_map = {
    'C': sprite('ciel.png'), # placeholder ceiling
    'L': sprite('wall_left.png'),
    'R': sprite('wall_right.png'),
    '1': sprite('ground1.png'),
    '2': sprite('ground2.png'),
    '3': sprite('ground3.png'),
    'T': sprite('topright_inside.png')

}



def make_map(layout):
    for i in range(len(layout)):
        if 'X' in layout[i
]:
            origin = (layout[i
].index('X'), i)
    
    for i in range(len(layout)):
        for j in range(len(layout[i
])):
            if layout[i
][j
] in '. X':
                continue

            t = Tile()

            x = abs(100 * (origin[0
]-j))
            x *= -1 if j < origin[0
] else 1
            t.x = x

            y = abs(100 * (origin[1
]-i))
            y *= 1 if i < origin[1
] else -1
            t.y = y

            t.sprite = tile_map[layout[i
][j
]
]"
}
},
{"gamecreation.py":{
"type":"function script","head":"
def createblock(x, y, w, h, debug=False):
    \"\"\"Basic opaque block. Takes args for pos, size, and optional block sprite.\"\"\"
    #construct block and set args
    a = Block()
    a.x = x
    a.y = y
    #This works for 40x40 sprite. For other sprites, change divisor accordingly
    a.sprite = new_sprite('debug.png') # For debugging
    a.scaleX = w/40
    a.scaleY = h/40
    
    if not debug:
        a.visible = False
        a.debug = False
    else:
        a.debug = True

    #store these for collision purposes
    a.wid = w/2
    a.ht = h/2
    a.nf = y+a.ht
    a.sf = y-a.ht
    a.wf = x-a.wid
    a.ef = x+a.wid
    
    return a

def blockgroup(x, y, posl, debug=False):
    \"\"\"Creates a group of blocks at a x and y position,
    given a list  of block constructs. posl is a list of tuples,
    each of the form (x, y, w, h).\"\"\"
    for bx, by, bw, bh in posl:
        createblock(bx+x, by+y, bw, bh, debug)"
}
}
]
}
}