{"assets":{
"script":[
{"Game":{
"type":"game script","start":"# current time\r
self.t = time_ms()\r
# general purpose frame counter\r
self.c = 0\r
\r
self.debug = False\r
self.showgrid = False\r
# create grid guides\r
if self.showgrid:\r
    for i in range(-20, 21):\r
        for j in range(-10, 11):\r
            temp = Slate()\r
            temp.x = i*100\r
            temp.y = j*100\r
            temp.sprite = new_sprite(\"Guide.png\")\r
            temp.persistent = True\r
            temp.scaleX = 0.6\r
            temp.scaleY = 0.6\r
            temp.z = 150\r
\r
self.travelid = None\r
self.fpslog = int(self.t/1000)\r
self.fpscount = 0\r
\r
self.dark = False\r
self.water_height = None\r
\r
self.prog = ProgTracker()\r
self.npcs = [
]\r
self.e = False\r
self.p = Player()\r
self.bg = Background()\r
\r
self.deaths = 0\r
self.start_time = datetime.datetime.now()\r
\r
# set_room('Demo_Room')\r
\r
self.music = SoundManager()\r
self.music.persistent = True\r
self.music.visible = False\r
set_room('R1_1')","loop":"self.t = time_ms()\r
self.c += 1\r
\r
self.fpscount += 1\r
ntime = int(self.t/1000)\r
\r
if ntime > self.fpslog:\r
    self.fpslog = ntime\r
    print(f\"Frames elapsed in last second: {self.fpscount
}\")\r
    self.fpscount = 0"
}
},
{"Player":{
"type":"object script","start":"# initialise pos, sprite
self.x = 0
self.y = 0
self.z = 11
self.sprite = new_sprite(\"debug.png\")
self.scaleX = 1
self.scaleY = 1
self.rad = self.scaleX*20
self.persistent = True

# velocity values
self.xv = 0
self.yv = 0
self.boostx, self.boosty = 0, 0

# For camera offset
self.y_off = 0
self.x_off = 0

# store previous values
self.x0 = 0
self.y0 = 0

# sprite that user normally sees
self.spr_obj = Psprite()
# flag for determining animation vs static
self.moving = False

# for debug mode
self.visible = game.debug

#store death spritesheet
self.death_anim = new_sprite(\"Player_Death.png\", 3, 3)
self.dead = False
self.dead_c = 0

self.xMOD = 0
self.yMOD = 0
self.cxMOD = 0
self.cyMOD = 0

self.xext = 0
self.yext = 0
self.cxext = 0
self.cyext = 0

self.fall_vel = 0

self.dash_cool = game.t
self.damage_cool = game.t
self.dmgF = True

self.echo_cool = game.t

self.hp = 5
self.healthbar = HealthInd()
self.healthbar.sprite = self.healthbar.spritemap[self.hp
]
self.healthbar.prev_h = self.hp

self.inv = list()","loop":"#Death animation
if self.dead:
    if self.dead_c >= 60:
        set_room(get_room().__name__)
        self.hp = 5
        self.dead = False
        self.dead_c = 0
        set_animation(self.spr_obj, self.spr_obj.anim)
        return

    self.dead_c += 1
    ind = self.dead_c // 15
    print(ind)
    set_animation(self.spr_obj, new_animation(self.death_anim, 0, ind, ind))
    return
    


camX, camY = camera_x(), camera_y()
xdist = (mouse_x()+camX) - self.x
ydist = (mouse_y()+camY) - self.y

# for arrow key movement
keys = [key_is_pressed('arrowRight'), 
        key_is_pressed('arrowLeft'), 
        key_is_pressed('arrowUp'),
        key_is_pressed('arrowDown')
]

# store previous position for movement rotation
self.x0, self.y0 = self.x, self.y

# prevent 0 trig errors
if not xdist and not ydist:
    xdist = 1

# get hypotenuse and adjust x & y for hyp of length 1
magn = hyp(xdist, ydist)
xdist, ydist = xdist/magn, ydist/magn


# move unless mouse is right on top of player
if mouse_is_pressed('left') and not magn < 25:
    do_move(self, xdist, ydist)

# allow for arrow-key movement
elif any(keys):
    xdist=ydist=0
    if keys[0
]: xdist = 1
    if keys[1
]: xdist = -1
    if keys[2
]: ydist = 1
    if keys[3
]: ydist = -1
    magn = hyp(xdist, ydist)
    xdist, ydist = xdist/magn, ydist/magn

    do_move(self, xdist, ydist)

else:
    # \"water resistance\" deteriorate velocity
    self.xv = deter(self.xv, 0.95)
    self.yv = deter(self.yv, 0.95)
    
# dash
if ((key_was_pressed(' ') or mouse_was_pressed('right')) and game.t > self.dash_cool):
    self.boostx = xdist*16
    self.boosty = ydist*16
    self.dash_cool = game.t + 600

#for external movement modifiers(boosters, jelly)
self.xext = (self.xMOD if abs(self.xMOD)>abs(self.xext) else self.xext)
self.yext = (self.yMOD if abs(self.yMOD)>abs(self.yext) else self.yext)

#current (ugly fix)
self.cxext = (self.cxMOD if abs(self.cxMOD)>abs(self.cxext) else self.cxext)
self.cyext = (self.cyMOD if abs(self.cyMOD)>abs(self.cyext) else self.cyext)

# deteriorate boost velocity
self.boostx, self.boosty = deter(self.boostx, 0.94), deter(self.boosty, 0.94)
#deteriorate external modif & current
self.xext, self.yext = deter(self.xext, 0.96), deter(self.yext, 0.96)
self.cxext, self.cyext = deter(self.cxext, 0.96), deter(self.cyext, 0.94)

# final movement values in x and y
a, b = (self.xv+self.boostx+self.xext+self.cxext), (self.yv+self.boosty+self.yext+self.cyext)

if game.water_height is not None:
    if self.y > game.water_height:
        self.fall_vel -= 0.5
        b += self.fall_vel
    else:
        self.fall_vel = min(0, self.fall_vel+0.5)

self.x += a
self.y += b

self.xMOD, self.yMOD = 0, 0
self.cxMOD, self.cyMOD = 0, 0

# start or stop animation based on speed
if abs(a) + abs(b) > 2:
    if not self.moving:
        set_animation(self.spr_obj, self.spr_obj.anim)
        self.moving = True
else:
    if self.moving:
        self.spr_obj.sprite = self.spr_obj.static
        self.moving = False

# distance from camera after move
distX = self.x - camX
distY = self.y - camY

# update camera position either moves camera with delay
# following player or caps at set limits
new_camX = camX + (distX - distX/1.1) + self.x_off
new_camX = min(max(new_camX, game.cam_limit_x[0
]), game.cam_limit_x[1
])

new_camY = camY + (distY - distY/1.1) + self.y_off
new_camY = max(min(new_camY, game.cam_limit_y[0
]), game.cam_limit_y[1
])

set_camera(new_camX, new_camY)


# rotate in direction of movement
Dx, Dy = self.x-self.x0, self.y-self.y0
k0 = angle_helper(Dx, Dy)
if k0 != -361:
    self.angle = k0

update_spr(self.spr_obj, self.x, self.y, self.angle)

if game.npcs:
    npc_dists = [get_dist(o.x, o.y, self.x, self.y) for o in game.npcs
]
    near = min(npc_dists)
    if near < 150:
        n = game.npcs[npc_dists.index(near)
]
        if not n.e_popup:
            create_e(n)
        if key_was_pressed('e'):
            if isinstance(n, Pedestal):
                place_gem(n)
            else:
                create_msg(n)
    else:
        if game.e:
            destroy(game.e)
        for o in game.npcs:
            if o.e_popup:
                o.e_popup = False

if game.prog.echo:
    if key_was_pressed('f') and game.t > self.echo_cool:
        if any(keys):
            angle = self.angle
        else:
            a = get_angle(ydist) - 90
            angle = a if xdist > 0 else -a
        make_echo(self.x, self.y, angle)
        self.echo_cool = game.t + 700

# damage invincibility management
if self.damage_cool < game.t and not self.dmgF:
    self.dmgF = True
    self.spr_obj.alpha = 1
   
# death check
if self.hp < 1:
    self.dead = True
    # stop movement
    self.angle = 0
    update_spr(self.spr_obj, self.x, self.y, self.angle)
    self.xv = self.yv = self.boostx = self.boosty = 0
    self.xext = self.yext = self.xMOD = self.yMOD = 0



# Empty lines because I don't like it when code 
# is at the bottom of the screen"
}
},
{"Conventions":{
"type":"object script","start":"#This is for storing reference for future ease of use.

#==================== Z REFERENCE =======================
#Place any non-zero Z values here for reference, so we don't end up 
#setting objects to z-403285245 to place objects on top.
#BACKGROUND: -10
#pedestals: -8
#gems (on pedestal): -7
#waves: -6
#Dark area (black tiles): -5
#Spikes: 8
#Tiles: 9
#Player sprite: 10
#Player debug: 11
#Dark gradients: 24
#Text boxes: 25
#Health indicator: 26
#Gem (in inventory): 26
#If you come across an undocumented Z-value, add it here.","loop":""
}
},
{"gameplay":[
{"Block":{
"type":"object script","start":"#Block start
","loop":"
# Exit the loop early if far from player
pdistx = self.x - game.p.x
pdisty = self.y - game.p.y


if abs(pdistx) > 2200 or abs(pdisty) > 1600:
    if self.visible:
        self.visible = False
    return
else:
    if not self.visible:
        self.visible = True

pl = get_collision(self, \"Player\")
if pl:
    p_nf, p_sf, p_wf, p_ef = pl.y0+pl.rad, pl.y0-pl.rad, pl.x0-pl.rad, pl.x0+pl.rad

    if p_nf < self.sf or p_sf > self.nf:
        pl.y = pl.y0

    elif p_ef < self.wf or p_wf >= self.ef:
        pl.x = pl.x0
    
    # \"friction\" slowdown while colliding
    pl.xv = deter(pl.xv, 0.84)
    pl.yv = deter(pl.yv, 0.84)

al = get_collision(self, \"Anglerfish\")
if al:
    a_nf, a_sf, a_wf, a_ef = al.y0+40, al.y0-40, al.x0-40, al.x0+40

    if a_nf < self.sf or a_sf > self.nf:
        al.y = al.y0

    elif a_ef < self.wf or a_wf >= self.ef:
        al.x = al.x0"
}
},
{"Booster":{
"type":"object script","start":"#Booster start

self.disp = Slate()
spritesheet = sprite(\"boostersheet.png\", 4, 3)
self.anim = animation(spritesheet, 15, 0, 10)
set_animation(self.disp, self.anim)

filterConfig = {
    \"threshold\": 0.7,
    \"bloomScale\" : 2,
    \"brightness\" : 0.4,
    \"blur\" : 2,
    \"quality\" : 10,

}

advBloom = new_adv_bloom_filter(filterConfig)
add_filter(self.disp, advBloom)

self.sprite = sprite('debug.png')
self.visible = game.debug

self.scaleX = 1.4
self.scaleY = 1.4","loop":"#Booster loop

k = get_collision(self, \"Player\")
if k:
    boost(k, self.force, self.angle)
"
}
},
{"Bumper":{
"type":"object script","start":"#Bumper start

self.disp = Slate()
self.disp.scaleX = self.disp.scaleY = 0.6
spritesheet = sprite(\"bouncesheet.png\", 2, 1)
self.anim = animation(spritesheet, 2, 0, 1)
set_animation(self.disp, self.anim)

filterConfig = {
    \"threshold\": 0.825,
    \"bloomScale\" : 2,
    \"brightness\" : 0.3,
    \"blur\" : 2,
    \"quality\" : 10,

}

advBloom = new_adv_bloom_filter(filterConfig)
add_filter(self.disp, advBloom)

self.sprite = sprite('debug.png')
self.visible = game.debug

self.fl = False
self.scaleX = 1.3
self.scaleY = 1.3","loop":"#Bumper loop
k = get_collision(self, \"Player\")
if k and not self.fl:
    boost(k, self.force, k.angle-180)
    self.fl = True

if not k:
    self.fl = False

"
}
},
{"Current":{
"type":"object script","start":"self.sprite = new_sprite(\"debug.png\")
self.alpha = 0.3
self.visible = game.debug

#if temporary
self.temp = False
self.exp_time = 0

# offset from game counter to create particles right away
self.count_offset = game.c%40 + 1","loop":"#Current loop

if not (game.c - self.count_offset)%40:
    for i in range(self.dense):
        fx = random.randrange(self.x-self.w, self.x+self.w)
        fy = random.randrange(self.y-self.h, self.y+self.h)
        spr = 'current_particle_dark.png' if game.dark else 'current_particle.png'
        make_particle(fx, fy, self.xa, self.ya, spr, self)

k = get_collision(self, \"Player\")
if k:
    k.cxMOD += self.xa
    k.cyMOD += self.ya

if self.temp and game.t>self.exp_time:
    destroy(self)"
}
},
{"textbox_inst":{
"type":"object script","start":"#TextBox start

self.sprite = sprite('text_box.png')

# TextBox class that created instance
self.parent = None","loop":"#TextBox loop

self.parent.do_loop()"
}
},
{"Spike":{
"type":"object script","start":"#Spike start

self.fading = False
if game.dark:
    self.sprite = sprite(\"Spike1_dark.png\")
    self.alpha = 0
else:
    self.sprite = sprite(\"Spike1.png\")","loop":"#Spike loop
l = get_collision(self, \"Player\")
if l and l.dmgF:
    boost(l, 8, l.angle-180)
    damage(1)

if game.dark:
    if get_collision(self, 'Echolocation'):
        self.alpha = 1
        self.fading = True
    if self.fading:
        self.alpha -= 0.01
        if self.alpha <= 0:
            self.alpha = 0
            self.fading = False"
}
},
{"Hurtbox":{
"type":"object script","start":"self.sprite = new_sprite(\"debug.png\")
self.alpha = 0
#if temporary
self.temp = False
self.exp_time = 0
#Func holds a function that describes player movement after hurtbox collision.
#Can be redefined externally.
self.func = lambda a, l: boost(l, 10, l.angle-180)

if game.debug:
    self.alpha = 0.8","loop":"#Hurtbox loop
k = get_collision(self, \"Player\")

if k and k.dmgF:
    damage(self.dmg)
    self.func(self, k)

if self.temp and game.t > self.exp_time:
    destroy(self)"
}
},
{"Anglerfish":{
"type":"object script","start":"self.scale = 1

self.sprite = sprite(\"Anglerfish_dark.png\") if game.dark else sprite(\"Anglerfish.png\")

self.light = Slate()
self.light.sprite = new_sprite(\"Anglerfish_light.png\")
filterConfig = {
    \"threshold\": 0.5,
    \"bloomScale\" : 2,
    \"brightness\" : 1,
    \"blur\" : 2,
    \"quality\" : 10,

}
advBloom = new_adv_bloom_filter(filterConfig)
add_filter(self.light, advBloom)


self.scaleX = self.scale
self.scaleY = self.scale

transform(self.light, self.x, self.y, self.scale, self.scale)
self.alpha = 0
self.disabled = False
self.fading = False

self.x0 = 0
self.y0 = 0

self.h = make_hurtbox(self.x+30, self.y, 20, 20, 2)
self.h.parent = self
self.h.func = lambda s, pl: boost(pl, 10, s.parent.angle-90)","loop":"if self.disabled:
    return
self.x0 = self.x
self.y0 = self.y

dx = game.p.x - self.x 
dy = game.p.y - self.y

# reaction uppon approach
if hyp(dx, dy) < 200:
    if not game.dark:
        self.alpha = min(1, self.alpha+0.1)
    self.angle = angle_helper(dx, dy) + 90
    mod = 2/hyp(dx, dy)    
    self.x += dx*mod
    self.y += dy*mod
    if dx < 0:
        self.scaleY = -self.scale
    else:
        self.scaleY = self.scale
else:
    if not game.dark:
        self.alpha = max(0, self.alpha-0.1)

transform(self.light, self.x, self.y)
self.light.angle = self.angle
self.light.scaleY = self.scaleY

hitbox_rotate(self.h, self, self.angle, 30)

if game.dark:
    if get_collision(self, 'Echolocation'):
        self.alpha = 1
        self.fading = True
    if self.fading:
        self.alpha -= 0.02
        if self.alpha <= 0:
            self.alpha = 0
            self.fading = False"
}
},
{"Jellyfish":{
"type":"object script","start":"if game.dark:
    spritesheet = sprite(\"jelly_dark.png\", 1, 8)
else:
    spritesheet = sprite(\"jelly.png\", 1, 8)

self.anim = animation(spritesheet, 4, 0, 7)

self.fading = False
if game.dark:
    self.alpha = 0
else:
    set_animation(self, self.anim)

self.scaleX = 0.5
self.scaleY = 0.5

#bounce cap
self.bounce_h = Jellycap()
self.bounce_h.scaleX = 1.3
self.bounce_h.scaleY = 0.5","loop":"if game.dark:
    if get_collision(self, 'Echolocation'):
        self.alpha = 1
        self.fading = True
        set_animation(self, self.anim)
    if self.fading:
        self.alpha -= 0.01
        if self.alpha <= 0:
            self.alpha = 0"
}
},
{"Jellycap":{
"type":"object script","start":"#Helper class - special kind of booster for jellyfish caps
self.sprite = new_sprite(\"debug.png\")
self.z = 100
if not game.debug:
    self.alpha = 0
    
#prevent double collisions
self.mcf = False
","loop":"#Jellycap loop
k = get_collision(self, \"Player\")
if k and not self.mcf:
    f0 = (2*self.angle) - (k.angle-180)
    boost(k, 20, f0)
    self.mcf = True

if not k:
    self.mcf = False
"
}
},
{"Echolocation":{
"type":"object script","start":"self.sprite = sprite('sonar_beam.png')
self.angle = game.p.angle
self.scaleX = 0.3
self.scaleY = 0.5

self.deathtime = game.c + 40","loop":"self.x += self.xvel\r
self.y += self.yvel\r
self.scaleX += 0.09\r
self.scaleY += 0.06\r
\r
if game.dark:\r
    t_col = get_collision_list(self, 'Tile')\r
    if t_col:\r
        for t in t_col:\r
            t.alpha = 1\r
            t.fading = True\r
            t.visible = True\r
\r
if game.c > self.deathtime:\r
    destroy(self)"
}
},
{"travelgate_inst":{
"type":"object script","start":"#travel_gate start

# reference to TravelGate class that created instance
self.parent = None","loop":"#travel_gate loop

if get_collision(self, 'Player'):
    self.parent.travel()"
}
},
{"Nautilus":{
"type":"object script","start":"#Nautilus start

self.hitbox = make_hurtbox(0, 0, 150, 180, 1, lambda a, l: boost(l, 20, l.angle-180))
#self.hitbox.alpha = 1
self.hurtbox = Slate()
self.hurtbox.sprite = new_sprite(\"debug.png\")
self.hurtbox.scaleX = 2.5
self.hurtbox.scaleY = 1.8
self.scaleX = -2
self.scaleY = 2
self.alpha = 1
self.hurtbox.visible = False
self.hp = 15
self.vulnerable = True

self.gate = make_current(1800, -500, 500, 1100, -25, 0)
#Store animations
self.idleAnim = new_animation(new_sprite(\"N_Idle.png\", 3, 2), 8, 0, 5)
self.spikeAnim = new_animation(new_sprite(\"N_Spike_Shoot.png\", 5, 4), 8, 0, 16)
self.summonAnim = new_animation(new_sprite(\"N_Summon.png\", 4, 4), 8, 0, 15)
self.shockwaveAnim = new_animation(new_sprite(\"N_Shockwave.png\", 4, 4), 8, 0, 13)
self.dashAnim = new_animation(new_sprite(\"N_Spike.png\", 4, 4), 4, 0, 14)
self.hurtAnim = new_animation(new_sprite(\"N_Hit.png\", 3, 2), 8, 0, 5)
self.deathAnim = new_sprite(\"N_Death.png\", 4, 4)

#dict for mapping attack id to animation
self.animdict = {
    0: self.spikeAnim,
    1: self.dashAnim,
    2: self.summonAnim,
    3: self.shockwaveAnim

}

set_animation(self, self.idleAnim)
self.z = 5
self.counter = 0

#order: spikes, dash, summon, shockwave
self.timedict = [60, 120, 90, 120
]
self.weights = [
    [60, 10, 30, 0
],

    [30, 15, 30, 25
],

    [5, 40, 25, 30
],

    [0, 50, 0, 50
]

]
self.attackdict = {
    0: summon_spike,
    1: dash,
    2: summon_sfish,
    3: shockwave

}

self.wlevel = 0

self.clock =  0
self.wanderc = 1
self.t = 0
self.xv = 0
self.yv = 0

self.resetX = 0
self.resetY = 0
self.resettime = 0
self.inDash = False
self.dashEnd = 0
self.ispending = False
self.pending = 0
self.attdelay = 0

#health bar
self.bossbar = new_sprite(\"BossBar.png\", 16, 1)
self.barobj = Slate()
self.barobj.z = 10
update_bar(self.barobj, self.hp, self)

self.dead = False
self.death_t = 0








","loop":"
if self.dead:
    if self.death_t > 120:
        return
    self.death_t += 1
    k = self.death_t//8
    set_animation(self, new_animation(self.deathAnim, 0, k, k))
    return
    
#distance check
if abs(self.x - game.p.x) > 1800:
    return None
#damaged by player
pl = get_collision(self.hurtbox, \"Player\")
if self.vulnerable and pl:
    #Player must be boosting
    if pl.boostx or pl.boosty:
        self.hp -= 1
        update_bar(self.barobj, self.hp, self)
        wander(self, 4)
        boost(pl, 35, -90)
        
    else:
        boost(pl, 10, -90)

if self.hp <= 0:
    self.dead = True
    destroy(self.barobj)
    destroy(self.gate)
    destroy(self.hurtbox)
    self.time0 = int(time.time())
#move healthbar
self.barobj.x = camera_x()
self.barobj.y = camera_y()+300
#Attacking
if self.clock >= 80:
    if self.wlevel == 3 or random.randint(0, 1):
        self.pending = gen_att(self.weights[self.wlevel
])
        self.ispending = True
        self.attdelay = 60
        self.wlevel = 0
        if self.pending < 2:
            self.scaleX = -3
            self.scaleY = 3
        set_animation(self, self.animdict[self.pending
])
    else:
        self.clock = 1
        self.wlevel += 1

if self.clock == 0:
    self.vulnerable = True
    set_animation(self, self.idleAnim)
    self.scaleX = -2
    self.scaleY = 2

#Timing for attack events
self.clock += 1
if self.ispending:
    self.vulnerable = False
    self.clock = -1 * self.timedict[self.pending
]
    self.attdelay -= 1
    if not self.attdelay:
        self.attackdict[self.pending
](self)
        self.ispending = False
        



#Random \"wandering\"
if self.wanderc > 90 and not self.inDash:

    n = random.randrange(1, 4)
    if n==1:
        wander(self)
        self.wanderc = 0
    else:
        self.wanderc -= 15
  
#Dash helpers
#For appearing on the other side of screen
if self.inDash and self.resettime == self.t:
    self.x = self.resetX
    self.y = self.resetY

#Ending dash
if self.inDash and self.dashEnd == self.t:
    self.xv = 0
    self.yv = 0
    self.inDash = False
    wander(self)

self.wanderc += 1
self.t += 1

#move
self.x += self.xv
self.y += self.yv

#hit/hurtbox alignment
hitbox_rotate(self.hitbox, self, self.angle+210, 60)
hitbox_rotate(self.hurtbox, self, self.angle-35, 75)





"
}
},
{"Swordfish":{
"type":"object script","start":"#Swordfish start

self.active = False
self.alert = True

self.fading = False
self.alpha = 1
self.sprite = sprite(\"Swordfish.png\")


self.h = make_hurtbox(self.x+30, self.y, 20, 20, 2)
self.h.parent = self
self.h.func = lambda s, pl: boost(pl, 10, s.parent.angle-90)","loop":"#Swordfish loop
if not self.ai:
    return

if self.alert and not self.active:
    Dx, Dy = game.p.x - self.x, game.p.y - self.y
    k = angle_helper(Dx, Dy) + 90
    if abs((self.angle - k)%360) < 10:
        self.active = True

if self.alert and self.active:
    i = (20*math.cos(math.radians(self.angle)))
    j = (20*math.sin(math.radians(self.angle)))
    self.x += i
    self.y += j
    self.h.x += i
    self.h.y += j
    k = get_collision(self.h, \"Block\")
    if k:
        self.alert = False
        destroy(self.h)




if self.fading and (not self.alert) and self.active:
    self.alpha -= 0.01
    if self.alpha <= 0:
        destroy(self)"
}
},
{"boss_spike":{
"type":"object script","start":"self.wait = game.t + 800
self.idle = True
self.sprite = new_sprite(\"Boss_Spike.png\")
self.scaleX = 1
self.scaleY = 1","loop":"#boss_spike loop
if self.idle and game.t > self.wait:
    self.idle = False
    Dx, Dy = game.p.x - self.x, game.p.y - self.y
    theta = angle_helper(Dx, Dy)
    self.angle = theta
    self.xv = math.cos(math.radians(self.angle+90)) * 20
    self.yv = math.sin(math.radians(self.angle+90)) * 20

if not self.idle:
    self.x += self.xv
    self.y += self.yv


pl = get_collision(self, \"Player\")
if pl:
    damage(1)
    destroy(self)
    boost(pl, 10, self.angle)

if game.t - self.wait > 3000:
    destroy(self)
"
}
}
]
},
{"Art":[
{"Psprite":{
"type":"object script","start":"#Hitbox start
self.z = 10
self.scaleX = 0.7
self.scaleY = 0.7


self.static = sprite('player_still.png')
spritesheet = sprite('dynamic_squid.png', 4, 4)
self.anim = animation(spritesheet, 10, 0, 12)

self.sprite = self.static
# set_animation(self, self.anim)

self.persistent = True","loop":"#Psprite loop

"
}
},
{"Tile":{
"type":"object script","start":"# Empty (at least for now) class that is used to make tiles\r
# Sprite gets set anyways\r
\r
\r
if game.dark:\r
    self.alpha = 0\r
self.fading = False","loop":"if game.dark:\r
    if self.fading:\r
        self.alpha -= 0.01\r
        if self.alpha <= 0:\r
            self.alpha = 0\r
            self.visible = False\r
            self.fading = False"
}
},
{"Particle":{
"type":"object script","start":"self.scaleX = 1.3
self.scaleY = 1.3","loop":"#Particle loop
if not (self.nb>=self.y>=self.sb) or not (self.wb<=self.x<=self.eb):
    destroy(self)

self.x += self.xv
self.y += self.yv"
}
},
{"Slate":{
"type":"object script","start":"#A blank object that can be used in any way by any other object.","loop":""
}
},
{"Pedestal":{
"type":"object script","start":"self.sprite = sprite('pedestal.png')
self.e_popup = False
self.e_offset = 250
self.z = -8
self.has_gem = False","loop":"#Pedestal loop

"
}
},
{"Gem":{
"type":"object script","start":"self.in_inv = False
self.placed = False
self.persistent = True

filterConfig = {
    \"threshold\": 0.8,
    \"bloomScale\" : 5,
    \"brightness\" : 0.7,
    \"blur\" : 2,
    \"quality\" : 10,

}

self.bloom_filter = new_adv_bloom_filter(filterConfig)
self.filterid = add_filter(self, self.bloom_filter)","loop":"if get_collision(self, 'Player') and not self.placed:
    self.in_inv = True
    self.z = 26
    game.p.inv.append(self)
    remove_filter(self, self.filterid)
    self.filterid = None
    game.prog.gem1_pick = True

if self.in_inv:
    self.x = camera_x() - 460
    self.y = camera_y() + 300

if self.placed:
    if self.persistent:
        self.persistent = False
        if self.filterid is None: # just placed, make filter again
            self.filterid = add_filter(self, self.bloom_filter)"
}
},
{"HealthInd":{
"type":"object script","start":"self.spritemap = {
    5: sprite('health_5.png'),
    4: sprite('health_4.png'),
    3: sprite('health_3.png'),
    2: sprite('health_2.png'),
    1: sprite('health_1.png'),
    0: sprite('health_0.png'),

}

self.persistent = True

self.x = -460
self.y = 180
self.scaleX = self.scaleY = 0.2

# just here for reference, gets set by player class
self.prev_h = None

self.z = 26","loop":"if game.p.hp != self.prev_h:
    self.sprite = self.spritemap[game.p.hp
]
self.prev_h = game.p.hp

self.x = camera_x() - 540
self.y = camera_y() + 260"
}
},
{"Background":{
"type":"object script","start":"#Background start

self.x = 0
self.y = 0
self.scaleX = 0.6
self.scaleY = 0.6
self.z = -10
self.persistent = True","loop":"#Background loop

if game.dark == self.visible:
    self.visible = not self.visible"
}
}
]
},
{"Whale":{
"type":"object script","start":"sprite_sheet = sprite('whalesheet.png', 1, 4)
self.anim = animation(sprite_sheet, 4, 0, 3)
set_animation(self, self.anim)

self.e_offset = 100

self.x, self.y = 1500, -420
self.visible = True

self.msg = 'Hi! I\\'m a whale!'
self.msg_duration = 1200

self.parent = None","loop":"try:
    # Exit the loop early if far from player
    pdist = get_dist(self.x, self.y, game.p.x, game.p.y)
    if pdist > 1700:
        if self.visible:
            self.visible = False
        return
    else:
        if not self.visible:
            self.visible = True
except AttributeError: # Whale created before player in Game start
    pass

if self.visible:
    d = game.c % 100
    
    if 0 <= d < 50:
        self.y += 0.5
    if 50 <= d < 100:
        self.y -= 0.5

if self.parent is not None:
    self.parent.update_loop()"
}
},
{"SoundManager":{
"type":"object script","start":"#SONG CREDIT: Terminus by meganeko

#SoundManager start
self.queue = [
]

#Uses time in seconds
self.orig = game.t // 1000

#Maps songs to their length for scheduling
#Key: mood no. -1
self.sl = [40, 36, 33, 36, 16, 29, 29, 30
]

#Store current song.
self.song = None

","loop":"#SoundManager loop

"
}
}
],
"room":[
{"Demo_Room":{
"type":"room script","start":"#Demo_Room start

game.bg = Background()
level = ['...CCC...','..BL.RB..','...L.R...','...L.R...', '...L.R...','...L.R...', '...LXR...', '...L.R...','.VCC.CCV.', '.L.....R.', '.VBNBNNV.'
]
        
make_map(level)

w = Whale()

bigwhale = Whale()
bigwhale.scaleX = bigwhale.scaleY = 3.5
bigwhale.x = bigwhale.y = -700

createblock(0, 600, 300, 95)

make_current(0, 0, 200, 200, 5, 2)
make_current(500, -500, 400, 400, 0, 9)
make_booster(500, 0, 225)
make_booster(0, -500, -45)
make_bumper(-250, 500)

game.cam_limit_x = (-1310, 1310)
game.cam_limit_y = (504, -504)

TextBox('Welcome to the demo room', 1500)","loop":"#Demo_Room loop

"
}
},
{"Menu":{
"type":"room script","start":"#Menu start

","loop":"#Menu loop

"
}
},
{"Stage1":[
{"Starting_Room":{
"type":"room script","start":"self.roomid = '0-1'

game.npcs.clear()
game.dark = False

game.cam_limit_x = (290, 1610)
game.cam_limit_y = (-110, -290)

if game.travelid == '0-0':
    smooth_tp(1900, -450)
else:
    smooth_tp(0, 0)

lvlmap = [
    '7CCCCCCCCCCCCCCCCCCCC6',
    'L....................R',
    'L..X.................R',
    'L....................R',
    'L....................R',
    'L....................2CCCC',
    'L.........................',
    'L.........................',
    '5VBNVBNNVNBBNVNVNBNBNVBNVN'

]
make_map(lvlmap)

game.bg.sprite = new_sprite(\"purple_bg.png\")
game.bg.scaleX = 2

# Make colliders
colliders = [
    (0, -400, 95, 900),
    (1050, 0, 2200, 95),
    (1250, -800, 2600, 95), 
    (2300, -250, 495, 595),

]

# From top left
blockgroup(-300, 200, colliders)

make_dark_gradient(2000, -450, 500, 400, 20)

self.gate = TravelGate(2220, -450, 60, 400, self.roomid, 'Hub_Room')

play_track(game.music, 2)","loop":"#Starting_Room loop

"
}
},
{"Hub_Room":{
"type":"room script","start":"self.roomid = '0-0'

game.npcs.clear()
game.dark = False
game.water_height = None

game.cam_limit_x = (10, 1810)
game.cam_limit_y = (-110, -1090)

if game.travelid == '0-1':
    smooth_tp(-350, -50)
elif game.travelid == '1-0':
    smooth_tp(1700, -1300)
elif game.travelid == '0-2':
    smooth_tp(2200, -750)
elif game.travelid == '2-0':
    smooth_tp(1550, -50)
else:
    smooth_tp(0, 0)

lvlmap = [
    '     7CCCCCCCCCCC6             ',
    'CCCCC3...........R  L..R       ',
    '......X..........R  L..R       ',
    '.................R  L..R       ',
    'NVBBV1...........R  L..R       ',
    '     L...........2CC3..2C6     ',
    '     5NNNNNNNN1..........R     ',
    '     7CCCCCCCC3..........R     ',
    '     L...................2CCCCC',
    '     L.........................',
    '     L.........................',
    '     L...................0VNBVB',
    '     5VNNNNNNNVNNBNVB1...R     ',
    '                     L...R     ',
    '                     L...R     ',
    '                     L...R     ',
    '                     L...R     ',

]
make_map(lvlmap)
game.bg.sprite = new_sprite(\"purple_bg.png\")
game.bg.x, game.bg.y = -100, -300
game.bg.scaleX = 2
game.bg.scaleY = 1.5

# from (0, 0)
colliders = [
    (-350, 150, 600, 195),
    (-350, -700, 595, 1095),
    (500, 200, 1300, 95),
    (300, -1300, 895, 695),
    (400, -450, 900, 200),
    (1250, -50, 395, 595),
    (1800, -50, 295, 595),
    (1550, 200, 400, 100)

]
blockgroup(0, 0, colliders)

# from (900, -300)
colliders = [
    (1250, -150, 595, 395),
    (200, -900, 895, 495),
    (1250, -850, 595, 595)

]
blockgroup(900, -300, colliders)

Winona(1500, -800)

make_dark_gradient(-350, -50, 600, 400, 20, direction=False)
TravelGate(-560, -50, 60, 400, self.roomid, 'Starting_Room')

make_dark_gradient(1700, -1200, 500, 500, 20, vert=True)
TravelGate(1700, -1400, 500, 60, self.roomid, 'R1_0')

make_dark_gradient(2150, -750, 600, 400, 20)
TravelGate(2400, -750, 60, 400, self.roomid, 'R0_2')

make_dark_gradient(1550, -100, 400, 500, 20, vert=True, direction=False)
TravelGate(1550, 100, 400, 60, self.roomid, 'R2_0')

stop_track(game.music)
play_track(game.music, 6)
# Empty lines for scroll glitch


","loop":"#Room1 loop

"
}
},
{"R0_2":{
"type":"room script","start":"self.roomid = '0-2'

game.npcs.clear()
game.dark = False

game.cam_limit_x = (-110, 1110)
game.cam_limit_y = (-110, -490)

if game.travelid == '0-0':
    smooth_tp(-500, -50)
else:
    smooth_tp(0, 0)

lvlmap = [
    '    7CCCCCCCCCCCCCCCCCCC6',
    'CCCC3...................R',
    '.......X................R',
    '........................R',
    'NNVB1...................R',
    '    L...................R',
    '    L...................R',
    '    L...................R',
    '    L...................R',
    '    L...................R',
    '    5VBNVBNNVVBVVNNBNBNB4',

]
make_map(lvlmap)

game.bg.sprite = new_sprite(\"purple_bg.png\")
game.bg.scaleX = 2

# Make colliders
colliders = [
    (-200, -50, 495, 195),
    (-200, -700, 495, 695),
    (1000, 0, 2100, 95),
    (2000, -500, 95, 1100),
    (1000, -1000, 2100, 95)

]

# From top left
blockgroup(-300, 200, colliders)

make_dark_gradient(-500, -50, 500, 400, 20, direction=False)
TravelGate(-700, -50, 60, 400, self.roomid, 'Hub_Room')

dialogue1 = (
    \"Howdy stranger! It's rare to see travellers nowadays...\
\"
    \"I'm Watson the Whale. Not much changes around these parts.\
\"
    \"We'd make cave paintings of the Sun to tell tales of the past,\
\"
    \"but we don't know how to paint.\")

dialogue2 = (
    \"Winona sent you, huh?\
\",
    \"So you want to hear about how we got stuck down here, eh?\"
)

dialogue3 = (
    \"We used to live up at the surface of the water,\
\"
    \"but one day, some scary creatures used 3 magic stones,\"
    \"and sealed all the water away.\
\"
    \"Man, of only there was a convenient hero that could get the stones and save us...\"
)

dialogue4 = (
    \"Oh hey! Do you want to go on a quest to save the world?\
\"
    \"You look like you can handle it!\"
)

make_simple_npc(500, -500, 'Whale', dialogue1)

play_track(game.music, 2)","loop":"#R0_2 loop

"
}
},
{"R1_0":{
"type":"room script","start":"game.npcs.clear()
game.dark = False

# ROOM ID - used for determining location when going to other rooms
self.roomid = '1-0'

game.cam_limit_x = (-10, 1610)
game.cam_limit_y = (290, -190)

if game.travelid == '0-0':
    smooth_tp(750, 400)
elif game.travelid == '1-1':
    smooth_tp(1950, -250)
elif game.travelid == '1-10':
    smooth_tp(-400, -250)
else:
    smooth_tp(0, 0)



# X is (0, 0)
lvlmap = [
    '            L..R         ',
    '            L..R         ',
    '            L..R         ',
    '            L..R         ',
    '    7CCCCCCC3..2CCCCCCCC6',
    '    L...................R',
    '    L.X.................R',
    'CCCC3...................2CCCC',
    '.............................',
    '.............................',
    'NVBB1...................0VBNN',
    '    5BNVBNNVNBBNVNVNBNBN4'

]
make_map(lvlmap)

game.bg.sprite = sprite(\"purple_bg.png\")
game.bg.x, game.bg.y = 300, -100
game.bg.scaleX = 2
game.bg.scaleY = 2

# make colliders
colliders = [
    (-200, -150, 495, 395),
    (-200, -650, 495, 195),
    (400, 200, 895, 495),
    (1550, 200, 995, 495),
    (1000, -700, 2100, 95),
    (2200, -150, 495, 395),
    (2200, -650, 495, 195)

]

# from top left
blockgroup(-200, 200, colliders)

make_current(575, -150, 350, 600, 1, -12)
make_current(925, -150, 350, 600, -5, 12)

make_current(1800, -250, 600, 300, -9, 0)

make_dark_gradient(2000, -250, 500, 400, 20)
TravelGate(2220, -250, 60, 400, self.roomid, 'R1_1')

make_dark_gradient(750, 400, 400, 500, 20, direction=False, vert=True)
TravelGate(750, 600, 400, 60, self.roomid, 'Hub_Room')

make_dark_gradient(-400, -250, 500, 400, 20, direction=False)
TravelGate(-600, -250, 60, 400, self.roomid, 'R1_10')

# set room music
stop_track(game.music)
play_track(game.music, 6)
# Empty lines for scroll glitch




","loop":"#1_0 loop

"
}
},
{"R1_1":{
"type":"room script","start":"game.npcs.clear()

game.dark = False

self.roomid = '1-1'

game.cam_limit_x = (-110, 1610)
game.cam_limit_y = (90, -90)

# room IDs and spawn locations for rooms that lead to this room
if game.travelid == '1-0':
    smooth_tp(-500, 50)
elif game.travelid == '1-2':
    smooth_tp(2100, 0)
else:
    smooth_tp(0, 0)


# X is (0, 0)
lvlmap = [
    '    7CCCCCCCCCCCCCCCCCCCC6    ',
    '    L....................R    ',
    'CCCC3....................2CCCC',
    '..............................',
    '.......X.NBVN....VBNB.........',
    'NVBV1.........................',
    '    L....................0VNBB',
    '    L....................R    ',
    '    5VBNVBNNVNBBNVNVNBNBN4    '

]
make_map(lvlmap)


# make colliders
colliders = [
    (750, 400, 2200, 95),
    (950, -400, 2600, 95), 
    (350, 0, 395, 95),
    (1150, 0, 395, 95),
    (-500, 300, 495, 295),
    (-500, -250, 495, 395),
    (2000, 300, 495, 295),
    (2000, -300, 495, 295),

]

blockgroup(0, 0, colliders)

# background configuration
game.bg.sprite = new_sprite(\"purple_bg.png\")
game.bg.x, game.bg.y = 300, 0
game.bg.scaleX = 2
game.bg.scaleY = 2

# create objects
make_current(750, 240, 2000, 220, 0, -8)
make_current(750, -240, 2000, 220, 0, 8)

for xc in range(200, 501, 100):
    make_spike(xc, 90, \"S\")
    make_spike(xc, -90, \"N\")

for xc in range(1000, 1301, 100):
    make_spike(xc, 90, \"S\")
    make_spike(xc, -90, \"N\")

make_booster(0, -300, -90)
make_booster(0, 300, -90)

make_booster(600, -300, -45)
make_booster(600, 300, -135)


# make gradients over exits/entrances
make_dark_gradient(2000, 0, 500, 500, 20)
TravelGate(2220, 0, 60, 500, self.roomid, 'R1_2')

make_dark_gradient(-500, 50, 500, 400, 20, direction=False)
TravelGate(-700, 50, 60, 400, self.roomid, 'R1_0')

# set room music
stop_track(game.music)
play_track(game.music, 1)
# Empty lines for scroll glitch





","loop":"#1_0 loop

"
}
},
{"R1_2":{
"type":"room script","start":"# npc list for player to check
game.npcs.clear()

# whether room is dark
game.dark = False

# ROOM ID - used for determining location when going to other rooms
self.roomid = '1-2'

# lowest(left) x + 640, highest(right) x - 640
game.cam_limit_x = (-110, 1610)
# highest y - 360, lowest y + 360
game.cam_limit_y = (90, -90)

# Insert room IDs and spawn locations for rooms that lead to this room
if game.travelid == '1-1':
    smooth_tp(-500, 50)
elif game.travelid == '1-3':
    smooth_tp(2100, 0)
else:
    smooth_tp(0, 0)


# X is (0, 0)
lvlmap = [
    '    7CCCCCCCCCCCCCCCCCCCC6',
    '    L....................R',
    'CCCC3...O................2CCCC',
    '........O.....................',
    '.......X......................',
    '.........................0VNNB',
    'NNBV1....................R',
    '    L....................R',
    '    5VBNVBNNVNBBNVNVNBNBN4'

]
make_map(lvlmap)


# make colliders
colliders = [
    (750, 400, 2200, 95),
    (950, -400, 2600, 95), 
    (100, 150, 95, 195),
    (-500, 300, 495, 295),
    (-500, -300, 495, 295),
    (2000, 300, 495, 295),
    (2000, -250, 495, 395),

]
blockgroup(0, 0, colliders)

# background configuration
game.bg.sprite = new_sprite(\"purple_bg.png\")
game.bg.x, game.bg.y = 300, 0
game.bg.scaleX = 2
game.bg.scaleY = 2

# room objects
make_current(900, 0, 1800, 700, -19, 0)
make_booster(0, -300, -90)
make_booster(400, -300, -45)
make_booster(400, 0, -90)
make_booster(700, 100, -90)
make_booster(1000, 100, 255)
make_booster(1300, 100, 270)
make_booster(1600, 100, 270)
make_spike(180, 100, \"W\")
make_spike(180, 200, \"W\")

make_dark_gradient(2000, 50, 500, 400, 20)
TravelGate(2200, 50, 60, 400, self.roomid, 'R1_3')

make_dark_gradient(-500, 0, 500, 500, 20, direction=False)
TravelGate(-700, 0, 60, 500, self.roomid, 'R1_1')



# set room music
stop_track(game.music)
play_track(game.music, 1)
# Empty lines for scroll glitch




","loop":"#R1_2 loop

"
}
},
{"R1_3":{
"type":"room script","start":"game.npcs.clear()
game.dark = False

# ROOM ID - used for determining location when going to other rooms
self.roomid = '1-3'

game.cam_limit_x = (-110, 1210)
# highest y - 360, lowest y + 360
game.cam_limit_y = (90, -490)

# Insert room IDs and spawn locations for rooms that lead to this room

if game.travelid == '1-2':
    smooth_tp(-600, 50)
elif game.travelid == '1-4':
    smooth_tp(1650, -650)
else:
    smooth_tp(0, 0)



# X is (0, 0)
lvlmap = [
    '    7CCCCCCCCCCCCCCCCCCCC6',
    '    L......RL.....RL.....R',
    'CCCC3......RL.....RL.....R',
    '...........67.....67.....R',
    '.......X.................R',
    'NVBB1......45.....45.....R',
    '    L......RL.....RL.....R',
    '    L......RL.....RL.....R',
    '    5VBNVBNNVNBBNVNVNB1..R',
    '                      L..R',
    '                      L..R',
    '                      L..R',
    '                      L..R',

]
make_map(lvlmap)


# make colliders
colliders = [
    (-500, 300, 495, 295),
    (-500, -250, 495, 395),
    (750, 400, 2200, 95),
    (600, -600, 1895, 495),
    (450, 200, 195, 295),
    (450, -200, 195, 295),
    (1150, 200, 195, 295),
    (1150, -200, 195, 295),
    (1800, -200, 95, 1300),

]
blockgroup(0, 0, colliders)

# background configuration
game.bg.sprite = new_sprite(\"purple_bg.png\")
game.bg.x, game.bg.y = 300, 0
game.bg.scaleX = 2
game.bg.scaleY = 2

# make room objects
make_anglerf(600, 0)
make_anglerf(1200, 0)


# gradients over exits/entrances
make_dark_gradient(-500, 50, 500, 400, 20, direction=False)
TravelGate(-700, 50, 60, 400, self.roomid, 'R1_2')

make_dark_gradient(1650, -600, 400, 500, 20, vert=True)
TravelGate(1650, -800, 400, 60, self.roomid, 'R1_4')

# set room music
stop_track(game.music)
play_track(game.music, 1)
# Empty lines for scroll glitch




","loop":"#R1_3 loop

"
}
},
{"R1_4":{
"type":"room script","start":"self.roomid = '1-4'

game.npcs.clear()
game.dark = False


# lowest(left) x + 640, highest(right) x - 640
game.cam_limit_x = (290, 310)
# highest y - 360, lowest y + 360
game.cam_limit_y = (290, -690)

# Insert room IDs and spawn locations for rooms that lead to this room
if game.travelid == '1-3':
    smooth_tp(750, 550)
elif game.travelid == '1-5':
    smooth_tp(-150, -900)
else:
    smooth_tp(0, 0)

# X is (0, 0)
lvlmap = [
    '         L..R',
    '         L..R',
    '         L..R',
    '         L..R',
    '7CCCCCCCCC..R',
    'L...........R',
    'L..X........R',
    'L...........R',
    'L...........R',
    'L...........R',
    'L...........R',
    'L...........R',
    'L..0VBNNBNBN4',
    'L..R          ',
    'L..R          ',
    'L..R          ',
    'L..R          ',

]
make_map(lvlmap)

# make colliders
colliders = [
    (450, 200, 995, 495),
    (1200, -200, 95, 1300),
    (750, -1000, 995, 495),
    (0, -600, 95, 1300)


]
# from top left
blockgroup(-300, 200, colliders)


# background manipulation
game.bg.sprite = new_sprite(\"purple_bg.png\")
game.bg.x, game.bg.y = 300, 500
game.bg.scaleX = 2
game.bg.scaleY = 2

Wilhelm(200, -200)

# gradients over exits/entrances
make_dark_gradient(-150, -800, 400, 500, 20, vert=True)
self.gate = TravelGate(-150, -1000, 400, 60, self.roomid, 'R1_5')

make_dark_gradient(750, 400, 400, 500, 20, vert=True, direction=False)
self.gate = TravelGate(750, 600, 400, 60, self.roomid, 'R1_3')


# set room music
stop_track(game.music)
play_track(game.music, 6)
# Empty lines for scroll glitch




","loop":"#R1_4 loop

"
}
},
{"R1_5":{
"type":"room script","start":"game.npcs.clear()
game.dark = True

# ROOM ID - used for determining location when going to other rooms
self.roomid = '1-5'

game.cam_limit_x = (-10, 1110)
game.cam_limit_y = (290, -290)

if game.travelid == '1-4':
    smooth_tp(750, 400)
elif game.travelid == '1-6':
    smooth_tp(-400, -250)
else:
    smooth_tp(0, 0)



# X is (0, 0)
lvlmap = [
    '            L..R        ',
    '            L..R        ',
    '            L..R        ',
    '            L..R        ',
    '    7CCCCCCCW..WCCCCCCC6',
    '    L.......L..........R',
    '    L.X.....L..........R',
    'CCCCA.......L..........R',
    '...........NLVNNBBB....R',
    '........R..............R',
    'NVBBA...R..............R',
    '    L...R..............R',
    '    5BNVBNNVNBBNVNVNBNB4',

]
make_map(lvlmap)

# make colliders
colliders = [
    (-200, -150, 495, 395),
    (-200, -650, 495, 195),
    (400, 200, 895, 495),
    (1550, 200, 995, 495),
    (1000, -800, 2100, 95),
    (1900, -400, 95, 900),

    (800, -200, 95, 495),
    (1050, -400, 795, 95),
    (400, -650, 95, 395)

]
# from top left
blockgroup(-200, 200, colliders)

make_light_gradient(750, 500, 200, 300, 25, vert=True, direction=False)
TravelGate(750, 600, 400, 60, self.roomid, 'R1_4')

make_light_gradient(-500, -250, 300, 200, 25, direction=False)
TravelGate(-600, -250, 60, 400, self.roomid, 'R1_6')

# set room music
stop_track(game.music)
play_track(game.music, 6)
# Empty lines for scroll glitch




","loop":"#R1_5 loop

"
}
},
{"R1_6":{
"type":"room script","start":"game.npcs.clear()
game.dark = True

# ROOM ID - used for determining location when going to other rooms
self.roomid = '1-6'

# lowest(left) x + 640, highest(right) x - 640
game.cam_limit_x = (290, 1610)
# highest y - 360, lowest y + 360
game.cam_limit_y = (90, -490)

# Insert room IDs and spawn locations for rooms that lead to this room
if game.travelid == '1-5':
    smooth_tp(2000, 50)
elif game.travelid == '1-7':
    smooth_tp(-100, -600)
else:
    smooth_tp(0, 0)


# X is (0, 0)
lvlmap = [
    'LCCCCCCCCCCCCCCCCCCCC6',
    'L....................R',
    'L.............RCCCL..DCCCC',
    'L.............R...L.......',
    'L..X.CCCCCCC..R...L.......',
    'L....R.....L..RCCCL..DVNNB',
    'L....R.....L.........R',
    'L....R.....L.........R',
    'S...SBNNVNBBNVNVNBNBN4',
    'L...R                 ',
    'L...R                 ',
    'L...R                 ',
    'L...R                 ',

]
make_map(lvlmap)

# make colliders
colliders = [
    (750, 400, 2200, 95),
    (950, -600, 1795, 495), 
    (2000, 300, 495, 295),
    (2000, -250, 495, 395),
    (-300, -200, 95, 1300),
    (1300, 50, 495, 395),
    (800, -150, 95, 395),
    (500, -200, 695, 495)

]
blockgroup(0, 0, colliders)

# room objects
make_anglerf(1650, 220)
make_spike(1580, 0, 'W')
make_spike(1580, -100, 'W')
for i in range(5):
    make_spike(1100 + (100*i), -180, 'N', scale=2-(0.2*i))
make_jelly(900, -300, -45)
for x in range(2):
    for i in range(3):
        make_spike(200 + (100*i) + (400*x), 80, 'S')
make_current(500, 200, 700, 300, 0, -8)
make_jelly(500, 100, 0)

make_light_gradient(2100, 50, 300, 200, 25)
TravelGate(2200, 50, 60, 400, self.roomid, 'R1_5')

make_light_gradient(-100, -700, 300, 300, 25, vert=True)
TravelGate(-100, -800, 500, 60, self.roomid, 'R1_7')


# set room music
stop_track(game.music)
play_track(game.music, 1)
# Empty lines for scroll glitch




","loop":"#R1_6 loop

"
}
},
{"R1_7":{
"type":"room script","start":"game.npcs.clear()
game.dark = True

# ROOM ID - used for determining location when going to other rooms
self.roomid = '1-7'

game.cam_limit_x = (-810, 10)
game.cam_limit_y = (190, -790)

if game.travelid == '1-6':
    smooth_tp(0, 400)
elif game.travelid == '1-8':
    smooth_tp(-1200, -650)
else:
    smooth_tp(0, 0)



# X is (0, 0)
lvlmap = [
    '            L...R    ',
    '            L...R    ',
    '            L...R    ',
    '            L...R    ',
    '            W...WCCC6',
    '            L.X.....R',
    '            L.......R',
    '            L.......R',
    '            L.......R',
    '    LCCCCCCCL.......R',
    'CCCCAf...............R',
    '..............NVBNVVR',
    '..............R      ',
    'NVBBA.........R      ',
    '    L.........R      ',
    '    L.........R      ',
    '    5BNVBNNVNBB      ',

]
make_map(lvlmap)

# make colliders
colliders = [
    (-600, 50, 895, 995),
    (400, 300, 495, 495),
    (600, -250, 95, 800),
    (300, -850, 695, 595),
    (-500, -1100, 1100, 95),
    (-1200, -950, 495, 395),
    (-1200, -450, 495, 195)


]
blockgroup(0, 0, colliders)

make_anglerf(-10, -480)
make_current(0, -400, 400, 400, -12, -7)
make_bumper(-100, -400)
make_anglerf(-600, -800)

make_light_gradient(0, 400, 300, 300, 25, vert=True, direction=False)
TravelGate(0, 500, 500, 60, self.roomid, 'R1_6')

make_light_gradient(-1300, 650, 300, 200, 25, direction=False)
TravelGate(-1400, -650, 60, 400, self.roomid, 'R1_8')

# set room music
stop_track(game.music)
play_track(game.music, 6)
# Empty lines for scroll glitch




","loop":"#R1_7 loop

"
}
},
{"R1_8":{
"type":"room script","start":"self.roomid = '1-8'

game.npcs.clear()
game.dark = False

game.cam_limit_x = (290, 1410)
game.cam_limit_y = (490, -290)

if game.travelid == '1-7':
    smooth_tp(1850, -450)
elif game.travelid == '1-9':
    smooth_tp(-150, 600)
else:
    smooth_tp(0, 0)


# X is (0, 0)
lvlmap = [
    'L..R                    ',
    'L..R                    ',
    'L..R                    ',
    'L..R                    ',
    'L..2CCCCCCCCCCCCCCCCC6  ',
    'L....................R  ',
    'L....................R  ',
    'L....................R  ',
    'L..X.................R  ',
    'L....................R  ',
    'L....................R  ',
    'L....................2CC',
    '5NVBBBNNVNBBNVNVNN1.....',
    '                  L.....',
    '                  5VNBBB',

]
make_map(lvlmap)

# make colliders
colliders = [
    (-300, 200, 95, 1300),
    (900, 600, 1895, 495),
    (1900, 50, 295, 795),
    (600, -500, 1895, 295),
    (1750, -600, 600, 95),

]
blockgroup(0, 0, colliders)

# background configuration
game.bg.sprite = sprite(\"purple_bg.png\")
game.bg.x, game.bg.y = 300, 0
game.bg.scaleX = 2
game.bg.scaleY = 2

for i in range(7):
    make_spike(1730, -300 + (100*i), 'E', 1 + ((i*0.1) * ((-1)**i)))
make_current(1450, -50, 200, 600, 13, 0)
make_current(1050, 50, 200, 600, 13, 0)

make_current(700, 150, 150, 400, 13, 0)
make_current(700, -250, 150, 180, 13, 0)

make_current(300, -50, 200, 600, 13, 0)
make_current(0, 50, 124, 600, 13, 0)

make_dark_gradient(1800, -450, 500, 400, 20)
TravelGate(2000, -450, 60, 400, self.roomid, 'R1_7')

make_dark_gradient(-150, 600, 400, 500, 20, vert=True, direction=False)
TravelGate(-150, 800, 500, 60, self.roomid, 'R1_10')


# set room music
stop_track(game.music)
play_track(game.music, 1)
# Empty lines for scroll glitch




","loop":"#R1_8 loop

"
}
},
{"R1_9":{
"type":"room script","start":"self.roomid = '1-9'

game.npcs.clear()
game.dark = True

game.cam_limit_x = (-210, 210)
game.cam_limit_y = (2290, -290)

# room IDs and spawn locations for rooms that lead to this room
if game.travelid == '1-8':
    smooth_tp(-50, -500)
elif game.travelid == '1-10':
    smooth_tp(0, 2500)
else:
    smooth_tp(0, 0)

# X is (0, 0)
lvlmap = [
    '       L...R       ',
    '       L...R       ',
    '       L...R       ',
    '       L...R       ',
    '  CCCCCW...WCCCCC  ',
    '  L.............R  ',
    '  L.............R  ',
    '  L.............R  ',
    '  L.............R  ',
    '  L.............R  ',
    '  L.............R  ',
    '  VBNL.......RNNB  ',
    '     L.......R     ',
    '     L.......R     ',
    '     L.......R     ',
    '     L.......R     ',
    '     L.......R     ',
    ' LCCCC.......CCCCR ',
    ' L...............R ',
    ' LVBN............R ',
    ' L...............R ',
    ' L............NBVR ',
    ' L...............R ',
    ' LVBN....X.......R ',
    ' L...............R ',
    ' VNBBNNS..SVBNNVBN ',
    '       R..L        ',
    '       R..L        ',
    '       R..L        ',
    '       R..L        ',

]
make_map(lvlmap)

# make colliders
colliders = [
    (250, -50, 595, 595),
    (1150, -50, 595, 595),
    (0, -650, 95, 800),
    (1400, -650, 95, 800),
    (100, -1300, 495, 695),
    (1300, -1300, 495, 695),

]
# from top left top section
blockgroup(-700, 2200, colliders)
colliders = [
    (0, -400, 95, 900),
    (1600, -400, 95, 900),
    (300, -1000, 695, 495),
    (1200, -1000, 695, 495),
    (150, -200, 395, 95),
    (1450, -400, 395, 95),
    (150, -600, 395, 95),

]
#from top left bottom section
blockgroup(-800, 600, colliders)

# make objects here
# JELLY - x, y, angle, scale=1
# CURRENT - x, y, w, h, xa, ya
# BOOSTER - x, y, angle, force=30
# SFISH - x, y, angle, AI=True
# BOUNCER/(bumper) - x, y, force=30
# ANGLERF - x, y, AI=True
# SPIKE - x, y, point_d, scale=1

for x in range(3):
    for i in range(9):
        if x == 2 and i in (3, 5, 7):
            make_jelly(-400 + 100*i + 300*(x%2), 200*x, 180)    
        else:
            make_jelly(-400 + 100*i, 200*x, 0)
make_current(100, 300, 700, 260, 0, 4)

make_current(0, 700, 700, 160, 0, -13)
make_spike(-320, 970, 'W')
make_spike(-320, 1040, 'W')
make_current(0, 1000, 700, 160, -15, 0)

make_anglerf(150, 1750)
make_anglerf(-150, 1750)
make_anglerf(0, 1650)

make_gem(0, 1750, 'gem_blue.png')

make_light_gradient(-50, -500, 200, 300, 25, vert=True)
TravelGate(-50, -600, 400, 60, self.roomid, 'R1_8')

make_light_gradient(0, 2200, 300, 300, 25, vert=True, direction=False)
TravelGate(0, 2300, 500, 60, self.roomid, 'R1_10')


# set room music
stop_track(game.music)
play_track(game.music, 6)
# Empty lines for scroll glitch




","loop":"#R1_9 loop

"
}
},
{"R1_10":{
"type":"room script","start":"game.npcs.clear()
game.dark = False

# ROOM ID - used for determining location when going to other rooms
self.roomid = '1-10'

game.cam_limit_x = (390, 1410)
game.cam_limit_y = (-10, -590)

if game.travelid == '1-9':
    smooth_tp(0, -750)
elif game.travelid == '1-0':
    smooth_tp(1900, -250)
else:
    smooth_tp(0, 0)



# X is (0, 0)
lvlmap = [
    '7CCCCCCCCCCCCCCCCC6',
    'L.................R',
    'L.................R',
    'L.X...............R',
    'L.................2CCCC',
    'L......................',
    'L......................',
    'L.................0VBNN',
    'L...0NNVNBBNVNBNBN4',
    'L...R              ',
    'L...R              ',
    'L...R              ',
    'L...R              ',

]
make_map(lvlmap)

game.bg.sprite = sprite(\"purple_bg.png\")
game.bg.x, game.bg.y = 300, -100
game.bg.scaleX = 2
game.bg.scaleY = 2
game.bg.z = -10

# make colliders
colliders = [
    (900, 0, 1900, 95),
    (0, -600, 95, 1295),
    (1100, -1000, 1495, 495),
    (2000, -750, 495, 195),
    (2000, -200, 495, 495),


]
# from top left
blockgroup(-200, 300, colliders)

make_current(700, -100, 1700, 700, 20, 0)

make_dark_gradient(1800, -250, 500, 400, 20)
TravelGate(2000, -250, 60, 400, self.roomid, 'R1_0')

make_dark_gradient(0, -700, 500, 500, 20, vert=True)
TravelGate(0, -900, 500, 60, self.roomid, 'R1_9')

# set room music
stop_track(game.music)
play_track(game.music, 6)
# Empty lines for scroll glitch




","loop":"#R1_10 loop

"
}
}
]
},
{"Stage2":[
{"R2_0":{
"type":"room script","start":"self.roomid = '2-0'

game.npcs.clear()
game.dark = False

self.placed = game.prog.gem1_place
self.water_rising = False
if not self.placed:
    game.water_height = -370

game.cam_limit_x = (291, 1009)
game.cam_limit_y = (-110, -690)

# Insert room IDs and spawn locations for rooms that lead to this room
if game.travelid == '2-1':
    smooth_tp(1500, 50)
elif game.travelid == '0-0':
    smooth_tp(-100, -800)
else:
    smooth_tp(0, 0)

# X is (0, 0)
lvlmap = [
    '7CCCCCCCCCCCCCCCCCCC',
    'L...................',
    'L..X................',
    'L..............0VNNB',
    'L..............R',
    'L..............R',
    'L..............R',
    'L..............R',
    'L..0BNNNVNBBVBN4',
    'L..R                 ',
    'L..R                 ',
    'L..R                 ',
    'L..R                 ',

]
make_map(lvlmap)

# make colliders
colliders = [
    (750, 200, 2200, 95),
    (600, -800, 1295, 495), 
    (-300, -400, 95, 1300),
    (1400, -350, 495, 595),


]
blockgroup(0, 0, colliders)


# background manipulation
game.bg.sprite = new_sprite(\"purple_bg.png\")
game.bg.x, game.bg.y = 1300, -1400
game.bg.scaleX = 2
game.bg.scaleY = 2

if not self.placed:
    self.water = list()
    spritesheet = sprite('wavesheet.png', 4, 1)
    anim = animation(spritesheet, 5, 0, 3)
    for i in range(4):
        s = Slate()
        s.x = 600*i
        s.y = -400
        s.z = -6
        set_animation(s, anim)
        self.water.append(s)

ped = make_pedestal(600, -420, 0.5, self.placed)
if self.placed:
    g = make_gem(ped.x, ped.y + (270 * ped.scaleY), 'gem_blue.png')
    g.placed = True
    g.z = -7

# gradients over exits/entrances
make_dark_gradient(1400, 50, 500, 400, 20)
if game.prog.gem1_place:
    TravelGate(1600, 50, 60, 400, self.roomid, 'R2_1')
else:
    self.exitblock = createblock(1600, 50, 60, 400)

make_dark_gradient(-150, -800, 400, 500, 20, vert=True)
TravelGate(-150, -1000, 400, 60, self.roomid, 'Hub_Room')

# set room music
stop_track(game.music)
play_track(game.music, 6)
# Empty lines for scroll glitch




","loop":"if game.prog.gem1_place and not self.placed:
    self.placed = True
    self.water_rising = True
    destroy(self.exitblock)
    TravelGate(1600, 50, 60, 400, self.roomid, 'R2_1')

if self.water_rising:
    if self.water[0
].y < 270:
        game.water_height += 4
        for w in self.water:
            w.y += 4"
}
},
{"R2_1":{
"type":"room script","start":"game.npcs.clear()\r
game.dark = False\r
\r
self.roomid = '2-1'\r
\r
game.cam_limit_x = (-108, 1108)\r
game.cam_limit_y = (-10, -90)\r
\r
# room IDs and spawn locations for rooms that lead to this room\r
if game.travelid == '2-0':\r
    smooth_tp(-450, 50)\r
elif game.travelid == '2-2':\r
    smooth_tp(1500, 50)\r
else:\r
    smooth_tp(0, 0)\r
\r
\r
# X is (0, 0)\r
lvlmap = [\r
    '    7CCCCCCCCCCCCCCC6    ',\r
    'CCCC3...............2CCCC',\r
    '.........................',\r
    '.......X.................',\r
    'NVBV1...............0NVBB',\r
    '    L...............R    ',\r
    '    L...............R    ',\r
    '    5VBNVBNNVNBBNVNB4    '\r

]\r
make_map(lvlmap)\r
\r
\r
# make colliders\r
colliders = [\r
    (750, 300, 2200, 95),\r
    (950, -400, 2600, 95), \r
    (-500, 300, 495, 295),\r
    (-500, -250, 495, 395),\r
    (1500, 300, 495, 295),\r
    (1500, -250, 495, 395),\r

]\r
\r
blockgroup(0, 0, colliders)\r
\r
# background configuration\r
game.bg.sprite = sprite(\"ocean_bg.png\")\r
game.bg.x, game.bg.y = -150, 1700\r
game.bg.scaleX = game.bg.scaleY = 1.5\r
\r
\r
\r
# make gradients over exits/entrances\r
make_dark_gradient(1500, 0, 500, 500, 20)\r
TravelGate(1700, 0, 60, 500, self.roomid, 'R2_2')\r
\r
make_dark_gradient(-500, 50, 500, 400, 20, direction=False)\r
TravelGate(-700, 50, 60, 400, self.roomid, 'R2_0')\r
\r
# set room music\r
stop_track(game.music)\r
play_track(game.music, 1)\r
# Empty lines for scroll glitch\r
\r
\r
\r
\r
\r
","loop":"#R2_1 loop

"
}
},
{"R2_2":{
"type":"room script","start":"game.npcs.clear()
game.dark = False

self.roomid = '2-2'

game.cam_limit_x = (-108, 1508)
game.cam_limit_y = (90, -90)

# room IDs and spawn locations for rooms that lead to this room
if game.travelid == '2-1':
    smooth_tp(-500, 50)
elif game.travelid == '2-3':
    smooth_tp(2000, 0)
else:
    smooth_tp(0, 0)


# X is (0, 0)
lvlmap = [
    '    7CCCCCCCCCCCCCCCCCCC6    ',
    '    L...................R    ',
    'CCCC3...................2CCCC',
    '.............................',
    '.......X.....................',
    'NVBV1........................',
    '    L...................0VNBB',
    '    L...................R    ',
    '    5VBNVBNNVNBBNVNVNBNB4    '

]
make_map(lvlmap)


# make colliders
colliders = [
    (750, 400, 2200, 95),
    (950, -400, 2600, 95), 
    (-500, 300, 495, 295),
    (-500, -250, 495, 395),
    (1900, 300, 495, 295),
    (1900, -300, 495, 295),

]

blockgroup(0, 0, colliders)

# background configuration
game.bg.sprite = sprite(\"ocean_bg.png\")
game.bg.x, game.bg.y = 50, 1300
game.bg.scaleX = game.bg.scaleY = 1.5

# make objects here
# JELLY - x, y, angle, scale=1
# CURRENT - x, y, w, h, xa, ya
# BOOSTER - x, y, angle, force=30
# SFISH - x, y, angle, AI=True
# BOUNCER/(bumper) - x, y, force=30
# ANGLERF - x, y, AI=True
# SPIKE - x, y, point_d, scale=1

for x in range(2):
    for i in range(9):
        make_sfish(-100 + (200*i) + (100*x), 300 - (600*x), -85 + (180*x))


# make gradients over exits/entrances
make_dark_gradient(1900, 0, 500, 500, 20)
TravelGate(2120, 0, 60, 500, self.roomid, 'R2_3')

make_dark_gradient(-500, 50, 500, 400, 20, direction=False)
TravelGate(-700, 50, 60, 400, self.roomid, 'R2_1')

# set room music
stop_track(game.music)
play_track(game.music, 1)
# Empty lines for scroll glitch





","loop":"#R2_2 loop

"
}
},
{"R2_3":{
"type":"room script","start":"game.npcs.clear()
game.dark = False

self.roomid = '2-3'

game.cam_limit_x = (-108, 1208)
game.cam_limit_y = (90, -190)

# room IDs and spawn locations for rooms that lead to this room
if game.travelid == '2-2':
    smooth_tp(-500, 50)
elif game.travelid == '2-4':
    smooth_tp(1500, 50)
else:
    smooth_tp(0, 0)


# X is (0, 0)
lvlmap = [
    '    7CCCCCCCCCCCCCCCC6    ',
    '    L................R    ',
    'CCCC3................2CCCC',
    '..........................',
    '.......X..................',
    'NVBV1................0NNVB',
    '    L................R    ',
    '    L................R    ',
    '    L................R    ',
    '    5VBNVBNNVNBBNVNVN4    '

]
make_map(lvlmap)


# make colliders
colliders = [
    (-500, 302, 495, 295),
    (-500, -300, 495, 495),
    (750, 400, 2200, 95),
    (750, -500, 2200, 95),
    (1600, 302, 495, 295),
    (1600, -300, 495, 495),

]
blockgroup(0, 0, colliders)

# background configuration
game.bg.sprite = sprite(\"ocean_bg.png\")
game.bg.x, game.bg.y = 30, 1000
game.bg.scaleX = game.bg.scaleY = 1.5

# make objects here
# JELLY - x, y, angle, scale=1
# CURRENT - x, y, w, h, xa, ya
# BOOSTER - x, y, angle, force=30
# SFISH - x, y, angle, AI=True
# BOUNCER/(bumper) - x, y, force=30
# ANGLERF - x, y, AI=True
# SPIKE - x, y, point_d, scale=1

make_current(550, -50, 1100, 800, 7, 0)

make_jelly(0, 0, -90)
make_jelly(200, 100, -90)
make_jelly(250, -300, -90)
make_jelly(475, 220, -90)
make_jelly(475, 320, -90)
make_jelly(420, -100, -90)
make_jelly(500, -400, -90)
make_jelly(600, -200, -90)
make_jelly(680,  60, -90)
make_jelly(900, -100, -90)
make_jelly(920, -300, -90)
make_jelly(950, 300, -90)
make_jelly(1150, 0, -90)


# make gradients over exits/entrances
make_dark_gradient(1600, 50, 500, 400, 20)
TravelGate(1800, 50, 60, 500, self.roomid, 'R2_4')

make_dark_gradient(-500, 50, 500, 400, 20, direction=False)
TravelGate(-700, 50, 60, 400, self.roomid, 'R2_2')

# set room music
stop_track(game.music)
play_track(game.music, 1)
# Empty lines for scroll glitch





","loop":"#R2_3 loop

"
}
},
{"R2_4":{
"type":"room script","start":"#R2_4 start

","loop":"#R2_4 loop

"
}
},
{"R2_5":{
"type":"room script","start":"#R2_5 start

","loop":"#R2_5 loop

"
}
},
{"R2_6":{
"type":"room script","start":"self.roomid = '2-0'

game.npcs.clear()
game.dark = False


self.water_rising = False


game.cam_limit_x = (290, 1790)
game.cam_limit_y = (-110, -1390)

# Insert room IDs and spawn locations for rooms that lead to this room

smooth_tp(2000, -300)

# X is (0, 0)
lvlmap = [
    '7CCCCCCCCCCCCCCCCCCC6    ',
    'L.......R L.........R    ',
    'L..X....R L.........R    ',
    'L.......R L.........RCCCC',
    'L.......R L...RCL........',
    'L.......R L...R L........',
    'L.......R L...RVC........',
    'L.......R L...RVCVNVBN0VB',
    'L.......R L...R          ',
    'L.......R L...RCCCC6.....',
    'L.......R L        R     ',
    'L.......R L        R     ',
    'LCCCCCCCR L        R     ',
    '........R 6VNBVN...R......',
    '........R L....R...R.....',
    '........R LCCCCC...R.....',
    'LVBNL..............R.....',
    'L...L..............R.....',
    'L...L..............R.....',
    'BBBNBVBNVBBVNBVBNBVN.....'

]
make_map(lvlmap)

# make colliders
colliders = [
    


]
blockgroup(0, 0, colliders)


# background manipulation
game.bg.sprite = new_sprite(\"purple_bg.png\")
game.bg.x, game.bg.y = 1300, -1400
game.bg.scaleX = 2
game.bg.scaleY = 2


# make stuff
make_booster(1500, -300, 0)
make_booster(1500,  0, 90)
make_booster(900, -900, -90)
make_booster(1400, -900, 180)
make_booster(900, -1500, 90)
make_booster(600, -1500, 90)
make_sfish(200, -1200, -90)
make_sfish(400, -1200, -90)
make_sfish(800, -500, 90)
make_sfish(1000, -500, 90)
make_sfish(800, -1400, 0)
make_sfish(800, -1600, 0)
# set room music
stop_track(game.music)
play_track(game.music, 6)
# Empty lines for scroll glitch




","loop":"#R2_6 loop

"
}
},
{"R2_7":{
"type":"room script","start":"#R2_7 start

","loop":"#R2_7 loop

"
}
},
{"R2_8":{
"type":"room script","start":"#R2_8 start

","loop":"#R2_8 loop

"
}
},
{"R3_B":{
"type":"room script","start":"# npc list for player to check
game.npcs.clear()

# whether room is dark
game.dark = False

# ROOM ID - used for determining location when going to other rooms
self.roomid = '3-B'

# lowest(left) x + 640, highest(right) x - 640
game.cam_limit_x = (490, 1510)
# highest y - 360, lowest y + 360
game.cam_limit_y = (-210, -790)

# Insert room IDs and spawn locations for rooms that lead to this room

smooth_tp(1900, -500)



# X is (0, 0)
lvlmap = [
    '7CCCCCCCCCCCCCCCCCCCCC6',
    'LX....................R',
    'L.....................R',
    'L.....................R',
    'L.....................R',
    'L......................',
    'L......................',
    'L......................',
    'L.....................R',
    'L.....................R',
    'L.....................R',
    'L.....................R',
    '5VBNVBNNVNBBNVNVNBNBNN4'

]
make_map(lvlmap)

# I didn't write this
game.bg.sprite = new_sprite(\"purple_bg.png\")
game.bg.x, game.bg.y = 500, -100
game.bg.scaleX = 2
game.bg.scaleY = 1.5

# make colliders
colliders = [
    (1000, 100, 2300, 100),
    (1000, -1100, 2300, 100),
    (-100, -500, 100, 1300),
    (2100, -100, 100, 500),
    (2100, -900, 100, 500)

]

# from top left
blockgroup(0, 0, colliders)

# make objects here

n = Nautilus()
n.x = 200
n.y = -500
# JELLY - x, y, angle, scale=1
# CURRENT - x, y, w, h, xa, ya
# BOOSTER - x, y, angle, force=30
# SFISH - x, y, angle, AI=True
# BOUNCER/(bumper) - x, y, force=30
# ANGLERF - x, y, AI=True
# SPIKE - x, y, point_d, scale=1


# make gradients over exits/entrances
# x, y, w, h, levels, direction=True, vert=False
# levels is number of different opacity rects to divide into
# direction True means top/left is lightest part (for exits going right/down)
# vert decides vertical or horizontal gradient

#self.gate = TravelGate(2220, -450, 60, 400, self.roomid, 'Room1')


# set room music
stop_track(game.music)
play_track(game.music, 6)
# Empty lines for scroll glitch




","loop":"#R3_B loop

"
}
}
]
},
{"Room_Template":{
"type":"room script","start":"# npc list for player to check
game.npcs.clear()

# whether room is dark
game.dark = False

# ROOM ID - used for determining location when going to other rooms
self.roomid = '69-69'

# lowest(left) x + 640, highest(right) x - 640
game.cam_limit_x = (290, 1610)
# highest y - 360, lowest y + 360
game.cam_limit_y = (-110, -290)

# Insert room IDs and spawn locations for rooms that lead to this room
if game.travelid == '1-0':
    smooth_tp(-350, -50)
else:
    smooth_tp(0, 0)


# X is (0, 0)
lvlmap = [
    '7CCCCCCCCCCCCCCCCCCCC6',
    'L....................R',
    'L..X.................R',
    'L....................R',
    'L....................R',
    'L....................2CCCC',
    'L.........................',
    'L.........................',
    '5VBNVBNNVNBBNVNVNBNBNVBNVN'

]
make_map(lvlmap)

# make colliders
colliders = [
    (0, -400, 95, 900),
    (1050, 0, 2200, 95),
    (1250, -800, 2600, 95), 
    (2300, -250, 495, 595),

]

# from top left
blockgroup(-300, 200, colliders)


# background manipulation
game.bg.sprite = new_sprite(\"purple_bg.png\")
game.bg.x, game.bg.y = -100, -300
game.bg.scaleX = 2
game.bg.scaleY = 1.5

# make objects here
# JELLY - x, y, angle, scale=1
# CURRENT - x, y, w, h, xa, ya
# BOOSTER - x, y, angle, force=30
# SFISH - x, y, angle, AI=True
# BOUNCER/(bumper) - x, y, force=30
# ANGLERF - x, y, AI=True
# SPIKE - x, y, point_d, scale=1

# make gradients over exits/entrances
# x, y, w, h, levels, direction=True, vert=False
# levels is number of different opacity rects to divide into
# direction True means top/left is lightest part (for exits going right/down)
# vert decides vertical or horizontal gradient
make_dark_gradient(2000, -450, 500, 400, 20)
self.gate = TravelGate(2220, -450, 60, 400, self.roomid, 'Room1')


# set room music
stop_track(game.music)
play_track(game.music, 6)
# Empty lines for scroll glitch




","loop":"#Room_Template loop

"
}
}
],
"texture":[
{"tiles":[
{"ground1.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615954594.ground1.png"
}
},
{"ground2.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615954601.ground2.png"
}
},
{"ground3.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616115967.ground3.png"
}
},
{"ciel.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616116213.ciel.png"
}
},
{"wall_left.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616115833.wall_left.png"
}
},
{"wall_right.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615954627.wall_right.png"
}
},
{"in_corner_tl.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616112361.in_corner_tl.png"
}
},
{"in_corner_tr.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616112366.in_corner_tr.png"
}
},
{"in_corner_bl.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616112369.in_corner_bl.png"
}
},
{"in_corner_br.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616112375.in_corner_br.png"
}
},
{"out_corner_tl.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616116555.out_corner_tl.png"
}
},
{"out_corner_tr.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616116613.out_corner_tr.png"
}
},
{"out_corner_bl.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616116633.out_corner_bl.png"
}
},
{"out_corner_br.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616116652.out_corner_br.png"
}
},
{"centre.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616570454.centre.png"
}
},
{"dark_tile.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616445786.dark_tile.png"
}
},
{"arrowN.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616622273.arrowN.png"
}
},
{"arrowW.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616622547.arrowW.png"
}
},
{"arrowS.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616622281.arrowS.png"
}
},
{"arrowE.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616622543.arrowE.png"
}
}
]
},
{"NPCs":[
{"whalesheet_gap.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615951543.whalesheet_gap.png"
}
}
]
},
{"Player":[
{"dynamic_squid.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615957753.dynamic_squid.png"
}
},
{"player_still.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616453331.player_still.png"
}
}
]
},
{"Stage1":[
{"gradient1.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615953211.gradient1.png"
}
},
{"pixel_bg_stage1.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1615960001.pixel_bg_stage1.png"
}
},
{"purple_bg.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616546270.purple_bg.png"
}
}
]
},
{"Stage2":[
{"Tiles2":[

]
},
{"Background2":[
{"ocean_bg.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616651496.ocean_bg.png"
}
},
{"waterBG.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.225782.1615667719.waterBG.png"
}
}
]
}
]
},
{"Gameplay_elements":[
{"boostersheet.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616545842.boostersheet.png"
}
},
{"bouncesheet.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616545187.bouncesheet.png"
}
},
{"wavesheet.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616715939.wavesheet.png"
}
},
{"sonar_beam.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616371496.sonar_beam.png"
}
},
{"Spike1.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225969.1616188359.Spike1.png"
}
},
{"Spike1_dark.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616456779.Spike1_dark.png"
}
},
{"Spike2.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225969.1616188331.Spike2.png"
}
}
]
},
{"Misc":[
{"pedestal.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616719495.pedestal.png"
}
},
{"text_box.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616039356.text_box.png"
}
},
{"black40x40.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616018445.black40x40.png"
}
},
{"white40x40.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616711624.white40x40.png"
}
},
{"debug.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1615942085.debug.png"
}
},
{"Guide.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1616348073.Guide.png"
}
},
{"current_particle_dark.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616627807.current_particle_dark.png"
}
},
{"current_particle.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616733563.current_particle.png"
}
},
{"exclaim_mark.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616656281.exclaim_mark.png"
}
}
]
},
{"Enemies":[
{"Swordfish.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616455645.Swordfish.png"
}
},
{"Swordfish_dark.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616456827.Swordfish_dark.png"
}
},
{"jelly.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616347498.jelly.png"
}
},
{"jelly_dark.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616456808.jelly_dark.png"
}
},
{"Anglerfish_light.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616275209.Anglerfish_light.png"
}
},
{"Anglerfish.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616275637.Anglerfish.png"
}
},
{"Anglerfish_dark.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616454910.Anglerfish_dark.png"
}
}
]
},
{"Tutorial":[
{"newE.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616348829.newE.png"
}
}
]
},
{"Boss":[
{"N_Cannon.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1616714721.N_Cannon.png"
}
},
{"N_Death.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1616714740.N_Death.png"
}
},
{"N_Hit.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1616714754.N_Hit.png"
}
},
{"N_Spike_Shoot.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225969.1616729211.N_Spike_Shoot.png"
}
},
{"N_Shockwave.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1616714811.N_Shockwave.png"
}
},
{"N_Spike.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225969.1616729202.N_Spike.png"
}
},
{"N_Idle.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1616714798.N_Idle.png"
}
},
{"N_Summon.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1616714855.N_Summon.png"
}
},
{"Boss_Spike.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225969.1616732075.Boss_Spike.png"
}
},
{"BossBar.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1616724553.BossBar.png"
}
}
]
},
{"Health":[
{"health_0.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616393393.health_0.png"
}
},
{"health_1.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616393407.health_1.png"
}
},
{"health_2.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616393414.health_2.png"
}
},
{"health_3.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616393422.health_3.png"
}
},
{"health_4.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616393430.health_4.png"
}
},
{"health_5.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616393438.health_5.png"
}
}
]
},
{"whalesheet.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616698467.whalesheet.png"
}
},
{"gem_blue.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616716515.gem_blue.png"
}
},
{"gem_red.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616716522.gem_red.png"
}
},
{"gem_rainbow.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226349.1616716536.gem_rainbow.png"
}
},
{"Player_Death.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1616737689.Player_Death.png"
}
}
],
"sound":[
{"Mood1.mp3":{
"type":"audio","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1616368556.Mood1.mp3"
}
},
{"Mood2.mp3":{
"type":"audio","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1616368566.Mood2.mp3"
}
},
{"Mood3.mp3":{
"type":"audio","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1616368576.Mood3.mp3"
}
},
{"Mood4.mp3":{
"type":"audio","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1616368585.Mood4.mp3"
}
},
{"Mood5.mp3":{
"type":"audio","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1616368596.Mood5.mp3"
}
},
{"Mood6.mp3":{
"type":"audio","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1616368609.Mood6.mp3"
}
},
{"Mood7.mp3":{
"type":"audio","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1616368620.Mood7.mp3"
}
},
{"Mood8.mp3":{
"type":"audio","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225456.1616368629.Mood8.mp3"
}
}
],
"function":[
{"imports.py":{
"type":"function script","head":"#File for imports to run before everything
import math
import time
import datetime
import random"
}
},
{"gamefuncs.py":{
"type":"function script","head":"#A collection of helper functions/enums.


def hyp(s, c) -> int:
    \"\"\"Return hypotenuse of right angle triangle.\"\"\"
    return math.sqrt((s**2)+(c**2))

def get_angle(y) -> float:
    \"\"\"Return angle of right angle triangle.
    
    Assumes hypotenuse is 1
    \"\"\"
    return math.degrees(math.asin(y))

def deter(val, k) -> int:
    \"\"\"Helper function that allows for movement deterioration
    while preventing rounding errors.\"\"\"
    if abs(val) <= 0.1: return 0
    return round(val*k, 3)

def get_dist(x1, y1, x2, y2):
    \"\"\"Return the distance between two points.\"\"\"
    return math.sqrt((x2-x1)**2 + (y2-y1)**2)

def do_move(pl, xdist, ydist):
    # Increase velocity
    pl.xv += (xdist*0.9)
    pl.yv += (ydist*0.9)
    
    # Get total velocity magnetude
    Vhyp = hyp(pl.xv, pl.yv)
    
    # Correct velocity speed
    if Vhyp > 6.5: # 6.5
        pl.xv = (pl.xv/Vhyp)*6.5
        pl.yv = (pl.yv/Vhyp)*6.5

def update_spr(plspr, x, y, angle):
    plspr.x = x
    plspr.y = y
    plspr.angle = angle

def angle_helper(Dx, Dy) -> int:
    \"\"\"This function returns the angle for an object moving in a specific direction.\"\"\"
    if not Dx and not Dy: Dx = 1
    m = hyp(Dx, Dy)
    Dy = Dy/m

    if m > 1:
        a = get_angle(Dy) - 90
        return a if Dx > 0 else -a
    
    return -361

def time_ms():
    return round(time.time() * 1000)

def boost(pl, force, angle):
    pl.xv = 0
    pl.yv = 0
    pl.boostx = 0
    pl.boosty = 0
    pl.xMOD += force * math.cos(math.radians(angle+90))
    pl.yMOD += force * math.sin(math.radians(angle+90))

def smooth_tp(x, y):
    \"\"\"Teleport the player to x and y and manage camera movement.\"\"\"

    offset_x = game.p.x - camera_x()
    offset_y = game.p.y - camera_y()
    game.p.x = x
    game.p.y = y

    new_camX = x + offset_x
    new_camY = y + offset_y
    new_camX = min(max(new_camX, game.cam_limit_x[0
]), game.cam_limit_x[1
])
    new_camY = max(min(new_camY, game.cam_limit_y[0
]), game.cam_limit_y[1
])
    set_camera(new_camX, new_camY)

def damage(st):
    if game.p.dmgF:
        game.p.hp -= st
        game.p.spr_obj.alpha = 0.6
        game.p.dmgF = False
        game.p.damage_cool = game.t + 600
        

def transform(obj, x, y, scaleX=None, scaleY=None):
    \"\"\"Simple transform helper for working with slates.\"\"\"
    obj.x = x
    obj.y = y
    if scaleX: obj.scaleX = scaleX
    if scaleY: obj.scaleY = scaleY

def hitbox_rotate(obj, orig, obj_0, rad):
    \"\"\"For rotating objects around a point.\"\"\"
    obj.x = (math.cos(math.radians(obj_0)) * rad) + orig.x
    obj.y = (math.sin(math.radians(obj_0)) * rad) + orig.y

def create_e(obj):
    # clear any current \"E\"s
    try:
        destroy(game.e)
    # no text box currently up
    except AttributeError:
        pass
    game.e = Slate()
    game.e.sprite = sprite('newE.png')
    game.e.scaleX = game.e.scaleY = 0.3
    game.e.x = obj.x
    game.e.y = obj.y + obj.e_offset
    obj.e_popup = True

def create_msg(obj):
    TextBox(obj.msg, obj.msg_duration)
    if obj.parent is None:
        try:
            destroy(game.e)
        except AttributeError: # no e currently up
            pass
    else:
        obj.parent.msg_ind += 1
        obj.parent.update_msg()

def play_track(s_obj, s_id):
    s_obj.song = new_sound(\"Mood\" + str(s_id) + \".mp3\")
    set_volume(s_obj.song, 0.3)
    loop_sound(s_obj.song)

def stop_track(s_obj):
    if s_obj.song != None:
        stop_sound(s_obj.song)
        s_obj.song = None

def place_gem(ped):
    if len(game.p.inv) and not ped.has_gem:
        g = game.p.inv[0
]
        g.x = ped.x
        g.y = ped.y + (270 * ped.scaleY)
        g.placed = True
        g.z = -7
        g.in_inv = False
        game.npcs.remove(ped)
        destroy(game.e)

        if not game.prog.gem1_place:
            game.prog.gem1_place = True
        elif not game.prog.gem2_place:
            game.prog.gem2_place = True
        elif not game.prog.gem3_place:
            game.prog.gem3_place = True
            # TRIGGER GAME END
        
        ped.has_gem = True

"
}
},
{"make_map.py":{
"type":"function script","head":"tile_map = {
    'C': (sprite('ciel.png'), ),
    'L': (sprite('wall_left.png'), ),
    'R': (sprite('wall_right.png'), ),
    'V': (sprite('ground1.png'), ),
    'B': (sprite('ground2.png'), ),
    'N': (sprite('ground3.png'), ),
    '0': (sprite('in_corner_tl.png'), ),
    '1': (sprite('in_corner_tr.png'), ),
    '2': (sprite('in_corner_bl.png'), ),
    '3': (sprite('in_corner_br.png'), ),
    '4': (sprite('out_corner_tl.png'), ),
    '5': (sprite('out_corner_tr.png'), ),
    '6': (sprite('out_corner_bl.png'), ),
    '7': (sprite('out_corner_br.png'), ),
    \"W\": (sprite(\"arrowN.png\"), ),
    \"D\": (sprite(\"arrowE.png\"), ),
    \"S\": (sprite(\"arrowS.png\"), ),
    \"A\": (sprite(\"arrowW.png\"), ),
    \"O\": (sprite(\"centre.png\"), ),
    \"~\": (sprite(\"black40x40.png\"), 2.5, 2.5, 0, 0, -5),

}
DARK_TILE = sprite('dark_tile.png')

def make_map(layout):
    for i in range(len(layout)):
        if 'X' in layout[i
]:
            origin = (layout[i
].index('X'), i)
    
    for i in range(len(layout)):
        for j in range(len(layout[i
])):
            key = layout[i
][j
]
            if key in '. X':
                continue
            elif key not in tile_map.keys():
                print(f'Unrecognised \"{layout[i
][j
]
} in level map.')
                continue

            t = Tile()

            t.x = 100 * (j - origin[0
])
            t.y = 100 * (origin[1
] - i)
            t.z = 9
            if len(tile_map[key
]) == 1:
                if key in 'WASD':
                    t.sprite = tile_map[key
][0
]
                else:
                    t.sprite = DARK_TILE if game.dark else tile_map[key
][0
]
            else:
                spr, scX, scY, x_off, y_off, z = tile_map[key
]
                t.sprite = spr
                t.scaleX = scX
                t.scaleY = scY
                t.x += x_off
                t.y -= y_off
                t.z = z







"
}
},
{"gamecreation.py":{
"type":"function script","head":"

d_to_angle = {
    \"N\": 0,
    \"W\": 90,
    \"S\": 180,
    \"E\": 270

}

def createblock(x, y, w, h):
    \"\"\"Basic opaque block. Takes args for pos, size, and optional block sprite.\"\"\"
    #construct block and set args
    a = Block()
    a.x = x
    a.y = y
    #This works for 40x40 sprite. For other sprites, change divisor accordingly
    a.sprite = sprite('debug.png') if game.debug else sprite('black40x40.png')
    a.scaleX = w/40
    a.scaleY = h/40
    
    if game.debug:
        a.alpha = 0.6
        a.z = 9
    else:
        a.z = -5

    #store these for collision purposes
    a.wid = w/2
    a.ht = h/2
    a.nf = y+a.ht
    a.sf = y-a.ht
    a.wf = x-a.wid
    a.ef = x+a.wid
    
    return a

def blockgroup(x, y, posl):
    \"\"\"Creates a group of blocks at a x and y position,
    given a list  of block constructs. posl is a list of tuples,
    each of the form (x, y, w, h).\"\"\"
    for bx, by, bw, bh in posl:
        createblock(bx+x, by+y, bw, bh)

def make_current(x, y, w, h, xa, ya):
    \"\"\"Create a current block, which takes arguments for
    position, size, and acceleration values.\"\"\"
    inst = Current()
    inst.x = x
    inst.y = y
    inst.scaleX = w/40
    inst.scaleY = h/40
    inst.xa = xa
    inst.ya = ya

    inst.w = w/2
    inst.h = h/2
    inst.dense = max((w*h)//20000, 1)
    return inst
    
def make_particle(x, y, xv, yv, spr, proc):
    \"\"\"Create a particle with a linear velocity. 
    Pass in a parent process that will kill the particle later.\"\"\"
    inst =  Particle()
    inst.x = x
    inst.y = y
    inst.sprite = new_sprite(spr)
    inst.xv = xv
    inst.yv = yv
    inst.parent = proc
    inst.nb = proc.y + proc.h
    inst.sb = proc.y - proc.h
    inst.eb = proc.x + proc.w
    inst.wb = proc.x - proc.w
    inst.angle = angle_helper(xv, yv) + 90

def make_booster(x, y, angle, force=30):
    \"\"\"A booster that launches you at a certain angle when touched.
    Force is given a default value, as for the sake of gameplay, faster boosters should
    be indicated as such to the player.\"\"\"
    inst = Booster()
    inst.x = inst.disp.x = x
    inst.y = inst.disp.y = y
    inst.angle = inst.disp.angle = angle
    inst.force = force

def make_bumper(x, y, force=30):
    \"\"\"A bumper that always sends you in the opposite direction 
    from when you last bumped into it.\"\"\"
    inst = Bumper()
    inst.x = inst.disp.x = x
    inst.y = inst.disp.y = y
    inst.force = force

def make_spike(x, y, point_d, scale=1):
    \"\"\"Make a spike at specified coords as well as a direction
    (N, S, E, W). Also takes optional arg for scale.\"\"\"
    inst = Spike()
    inst.x = x
    inst.y = y
    inst.angle = d_to_angle[point_d
]
    inst.scaleX *= scale
    inst.scaleY *= scale

def make_anglerf(x, y, AI=True):
    \"\"\"Create an anglerfish.\"\"\"
    inst = Anglerfish()
    inst.x = x
    inst.y = y
    
def make_hurtbox(x, y, w, h, dmg, boost_f=None):
    \"\"\"Create a hurtbox at a specific location, given dimenstions,
    damage value, and a player movement modification function\"\"\"
    inst = Hurtbox()
    inst.x = x
    inst.y = y
    
    inst.scaleX = w/40
    inst.scaleY = h/40
    inst.dmg = dmg
    if boost_f != None:
        inst.func = boost_f
    return inst

def make_jelly(x, y, angle, scale=1):
    \"\"\"Create a jellyfish pointing at a specfic angle.\"\"\"
    inst = Jellyfish()
    inst.x = x
    inst.y = y
    inst.angle = angle
    inst.scaleX *= scale
    inst.scaleY *= scale
    inst.bounce_h.x = x + math.cos(math.radians(angle+90))*20
    inst.bounce_h.y = y + math.sin(math.radians(angle+90))*20
    inst.bounce_h.angle = angle
    inst.bounce_h.scaleX *= scale
    inst.bounce_h.scaleY *= scale    
    inst.hbox = make_hurtbox(x, y+20, 40*scale, 30*scale, 1)
    hitbox_rotate(inst.hbox, inst, angle-90, 20)
    inst.hbox.angle = angle

def make_sfish(x, y, angle, AI=True):

    inst = Swordfish()
    inst.x = x
    inst.y = y
    inst.angle = angle
    inst.ai = AI
    hitbox_rotate(inst.h, inst, inst.angle, 40)
    inst.h.angle = angle
    if 90<angle<=270:
        inst.scaleY *= -1

    return inst

def make_echo(x, y, angle):
    e = Echolocation()
    e.x = x
    e.y = y
    e.angle = angle
    e.xvel = math.cos(math.radians(angle+90))*14
    e.yvel = math.sin(math.radians(angle+90))*14

def make_gem(x, y, sprname, scale=0.2):
    g = Gem()
    g.x = x
    g.y = y 
    g.sprite = sprite(sprname)
    g.scaleX = g.scaleY = scale
    return g

def make_pedestal(x, y, scale=1, placed=False):
    p = Pedestal()
    p.x = x
    p.y = y
    p.scaleX = p.scaleY = scale
    p.e_offset *= scale
    
    if not placed:
        game.npcs.append(p)
    
    return p



"
}
},
{"make_gradient.py":{
"type":"function script","head":"def make_dark_gradient(x, y, w, h, levels, direction=True, vert=False, over=True):
    \"\"\"Make a fade to black gradient centered around x, y of width
    w and height h.
    
    Arg \"levels\" specifies the number of steps to divide the gradient into
    Arg \"direction\" is True if top/left should be the lightest part
    Arg \"vert\" is True if gradient should be vertical
    Arg \"over\" decides if the gradient should go over the player
    \"\"\"
    
    width = w/levels if not vert else w
    height = h/levels if vert else h

    for i in range(levels):
        t = Slate()
        t.sprite = sprite('debug.png') if game.debug else sprite('black40x40.png')
        t.scaleX = (width/40)
        t.scaleY = (height/40)
        
        if vert:
            t.x = x 
            t.y = ((y + (h/2)) - (height/2)) - (height * i)
        else:
            t.x = (x - (w/2) + (width/2)) + (width * i)
            t.y = y

        t.alpha = (1/(levels-1)) * i if direction else 1 - ((1/(levels-1)) * i)

        if over: t.z = 24

def make_light_gradient(x, y, w, h, levels, direction=True, vert=False, over=True):
    \"\"\"Make a fade to white gradient centered around x, y of width
    w and height h.
    
    Arg \"levels\" specifies the number of steps to divide the gradient into
    Arg \"direction\" is True if top/left should be the lightest part
    Arg \"vert\" is True if gradient should be vertical
    Arg \"over\" decides if the gradient should go over the player
    \"\"\"
    
    width = w/levels if not vert else w
    height = h/levels if vert else h

    for i in range(levels):
        t = Slate()
        t.sprite = sprite('debug.png') if game.debug else sprite('white40x40.png')
        t.scaleX = (width/40)
        t.scaleY = (height/40)
        
        if vert:
            t.x = x 
            t.y = ((y + (h/2)) - (height/2)) - (height * i)
        else:
            t.x = (x - (w/2) + (width/2)) + (width * i)
            t.y = y

        t.alpha = (1/(levels-1)) * i if direction else 1 - ((1/(levels-1)) * i)
        t.alpha /= 3

        if over: t.z = 24

"
}
},
{"Nautilusfuncs.py":{
"type":"function script","head":"

def summon_spike(boss):
    \"\"\"Summons spikes around the boss, which
    then home towards the player.\"\"\"
    x0, y0 = boss.x, boss.y
    offset0 = random.randrange(0, 60)

    for i in range(6):
        inst = boss_spike()
        vangle = (i*60) + offset0
        gcos, gsin = math.cos(math.radians(vangle)), math.sin(math.radians(vangle))
        inst.x = (230*gcos) + boss.x
        inst.y = (230*gsin) + boss.y
        inst.angle = -1*(90-vangle)
        
def summon_sfish(boss):
    \"\"\"Summons swordfish.\"\"\"
    origin = boss.x
    t = random.choice([\"T\", \"B\"
])
    if t == \"T\":
        sy = 0
        sa = -90
    else:
        sy = -1000
        sa = 90

    for i in range(1, 7):
        k = make_sfish(origin + (i*160), sy, sa)
        k.fading = True

def shockwave(boss):
    \"\"\"Makes shockwave and sends player flying with massive current.\"\"\"
    x0, y0 = boss.x, boss.y
    hb = make_hurtbox(x0, y0, 600, 600, 2, lambda hb, pl: boost(pl, 20, -90))
    hb.temp = True
    hb.exp_time = game.t + 800
    cur = make_current(550, -500, 1200, 1100, 30, 0)
    cur.temp = True
    cur.exp_time = game.t + 2000

def dash(boss):
    \"\"\"Dash towards the player, dealing large damage.\"\"\"
    Dx, Dy = game.p.x - boss.x, game.p.y - boss.y
    Vmod = 20/hyp(Dx, Dy)
    boss.xv, boss.yv = Dx*Vmod, Dy*Vmod

    boss.inDash = True
    boss.resetX, boss.resetY = (boss.x - (40*boss.xv)), (boss.y - (40*boss.yv))
    boss.resettime = boss.t + 80
    boss.dashEnd = boss.t + 120
    boss.hitbox.dmg = 2

def wander(boss, v=2):
    \"\"\"Function for random movement.\"\"\"
    Dx, Dy = random.randrange(300, 500) - boss.x, random.randrange(-800, -200) - boss.y
    Vmod = v/hyp(Dx, Dy)
    boss.xv = Dx*Vmod
    boss.yv = Dy*Vmod

def gen_att(weights):
    \"\"\"Gets the resulting attack from a list of probabilities.\"\"\"
    seed = random.randrange(1, 101)
    base = 0
    for i in range(4):
        base += weights[i
]
        if base>=seed:
            return i

def update_bar(bar, val, boss):
    if not 0<=val<=15:
        return None
    anim = new_animation(boss.bossbar, 0, val, val)
    set_animation(boss.barobj, anim)

    


    

        
        

"
}
},
{"Classes":[
{"TravelGate.py":{
"type":"function script","head":"class TravelGate:
    def __init__(self, x, y, w, h, roomid, dest):
        self.inst = travelgate_inst()
        self.inst.parent = self
        self.inst.x = x
        self.inst.y = y
        
        self.inst.sprite = sprite('debug.png') if game.debug else sprite('black40x40.png')
        self.inst.visible = game.debug
        self.inst.scaleX = w/40
        self.inst.scaleY = h/40

        self.roomid = roomid
        self.dest = dest

    def travel(self):
        \"\"\"\"\"\"
        game.travelid = self.roomid
        set_room(self.dest)"
}
},
{"TextBox.py":{
"type":"function script","head":"class TextBox:
    def __init__(self, msg, duration):
        \"\"\"Create a textbox with msg text that last for a 
        minimum of duration ms.\"\"\"\"

        try: # clear possible current text box
            game.text_box.destroy()
        except Exception as e: # no text box currently up
            pass

        self.inst = textbox_inst()
        self.inst.parent = self
        self.inst.x = camera_x()
        self.inst.y = camera_y() - 200
        game.text_box = self
        
        self.text = text(msg, self.inst.x - 450, self.inst.y + 56)
        self.text.color = '#ffffff'
        self.text.fontsize = 70
        self.text.fontFamily = 'courier new'
        self.inst.z = 25
        self.text.z = 25

        self.close_time = game.t + duration
        self.textexists = True
    
    def do_loop(self):
        
        try:
            self.text.x 
        except Exception:
            self.textexists = False
        
        self.inst.x = camera_x()
        self.inst.y = camera_y() - 200
        
        if self.textexists:
            self.text.x = self.inst.x - 450
            self.text.y = self.inst.y + 56
        

        if game.t > self.close_time:
            keys = (
                mouse_is_pressed('left'),
                mouse_is_pressed('right'),
                key_is_pressed('arrowRight'),
                key_is_pressed('arrowLeft'),
                key_is_pressed('arrowDown'),
                key_is_pressed('arrowUp'),
                key_is_pressed(' ')
            )

            if any(keys):
                self.destroy()
        
    def destroy(self):
        destroy(self.inst)
        destroy(self.text)
    


"
}
},
{"NPC.py":{
"type":"function script","head":"
def make_simple_npc(x, y, type_, msg, scale=1, facingr=True):
    \"\"\"Create a simple npc with only one line.\"\"\"

    type_map = {
        'Whale': Whale
    
}

    n = type_map[type_
]()
    n.x = x
    n.y = y
    if not facingr:
        n.skewY = -180
    n.scaleX *= scale
    n.scaleY *= scale
    n.e_offset *= scale
    n.msg = msg
    
    # flag for if \"e to interact\" popup is up
    n.e_popup = False

    game.npcs.append(n)
    return n

class ComplexNPC:
    def __init__(self, x, y):
        self.inst = Whale()
        self.inst.x = x
        self.inst.y = y
        self.inst.e_popup = False
        self.inst.parent = self
        game.npcs.append(self.inst)

        self.msg_ind = 0
        self.mark = None
    
    def update_loop(self):
        if self.mark is not None:
            self.mark.y = self.inst.y + self.inst.e_offset

    def make_exclaim(self):
        self.mark = Slate()
        self.mark.sprite = sprite('exclaim_mark.png')
        self.mark.scaleX = self.mark.scaleY = 0.8

        # offset to left or right depending on facing
        if self.inst.skewY != 0:
            x_off = 110 * (self.inst.skewY/abs(self.inst.skewY))
        else:
            x_off = 110
        self.mark.x = self.inst.x + (x_off * self.inst.scaleX)
        self.mark.y = self.inst.y + self.inst.e_offset
    
    def destroy_exclaim(self):
        if self.mark is not None:
            destroy(self.mark)
            self.mark = None



WINONA_MSGS = [
[
\"\"\"Hi, I'm Winona the Whale! Glad you made it.
If you haven't been keeping up with current events,
the three gems that maintain the oceans were stolen, and
the water levels have fallen.\"\"\",

\"\"\"Most of the whales made it down here safely, but we're
too big to go in the caves where the gems were hidden.\"\"\",

\"\"\"If you want to help out, try talking to Watson the Whale. 
Cavern to the right, and just look for the biggest whale 
there.\"\"\"

],

[
\"\"\"Woah, you actually got the gem! Uh, I mean, I beleived
in you the whole time. Quick, go put it on the pedestal
in the room above to raise the water level!\"\"\",

],

[
\"\"\"Hey! Nice to see you again  Winona the Whale here.
Thanks so much for raising the water level. If you did it again,
all my friends could return home too.\"\"\",

],


]
class Winona(ComplexNPC):
    def __init__(self, x, y):
        super().__init__(x, y)
        self.inst.skewY = -180
        self.update_msg()
        
    def update_msg(self):
        if not game.prog.gem1_pick:
            self.msgs = WINONA_MSGS[0
]

            if not game.prog.winona_e1 and self.mark is None:
                self.make_exclaim()

            if self.msg_ind >= len(self.msgs):
                game.prog.winona_e1 = True
                self.destroy_exclaim()
        
        elif game.prog.gem1_pick:
            self.msgs = WINONA_MSGS[1
]

            if self.mark is not None:
                self.destroy_exclaim()
                game.prog.winona_e2 = True

            if not game.prog.winona_e2 and self.mark is None:
                self.make_exclaim()

        self.msg = self.msgs[self.msg_ind%len(self.msgs)
]
        self.inst.msg = self.msg
        
        if not self.msg_ind%len(self.msgs):
            try:
                destroy(game.e)
            except AttributeError:
                pass

WILHELM_MSGS = [
[
\"\"\"Hey there mate! Didn't expect to see anybody
else crazy enough to come down here. You'll be questing
for the gems, I expect.                 
                                        (1/3)\"\"\",

\"\"\"The caves up ahead got too narrow for my big head,
but you should be able to make it. You will need a
way to see in the dark though... Aha! I know just
the thing! I'll teach you Echolocation!   (2/3)
\"\"\",

\"\"\"So what you're going to want to do is press \"F\" when
you're in a dark cave, and everything hit by the
echolocation will light up. Good luck out there mate!
                                        (3/3)\"\"\",

],


]

class Wilhelm(ComplexNPC):
    def __init__(self, x, y):
        super().__init__(x, y)
        self.update_msg()
    
    def update_msg(self):
        self.msgs = WILHELM_MSGS[0
]
        if not game.prog.echo:
            self.make_exclaim()

            if self.msg_ind >= len(self.msgs):
                self.destroy_exclaim()
                game.prog.echo = True
        
        self.msg = self.msgs[self.msg_ind%len(self.msgs)
]
        self.inst.msg = self.msg

        if not self.msg_ind%len(self.msgs):
            try:
                destroy(game.e)
            except AttributeError:
                pass







"
}
},
{"ProgTracker.py":{
"type":"function script","head":"class ProgTracker:
    def __init__(self):
        
        self.echo = False
        self.gem1_pick = False
        self.gem1_place = False
        self.gem2_pick = False
        self.gem2_place = False
        self.gem3_pick = False
        self.gem3_place = False

        # exclamation marks for npcs - has player seen message
        self.winona_e1 = False
        self.winona_e2 = False
"
}
}
]
}
]
}
}