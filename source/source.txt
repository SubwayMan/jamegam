{"assets":{
"script":[
{"Game":{
"type":"game script","start":"self.bg = Background()\r
\r
w = Whale()\r
self.p = Player()\r
\r
bigwhale = Whale()\r
bigwhale.scaleX = bigwhale.scaleY = 2\r
bigwhale.x = bigwhale.y = -700\r
\r
k = createblock(600, 0, 200, 100, \"block.png\")","loop":""
}
},
{"Player":{
"type":"object script","start":"#initialise pos, sprite
self.x = 0
self.y = 0

self.sprite = new_sprite(\"debug.png\")

self.scaleX = 0.6
self.scaleY = 0.6

#velocity values
self.xv = 0
self.yv = 0
self.boostx, self.boosty = 0, 0

self.y_off = 0
self.x_off = 0

#Store previous values
self.x0 = 0
self.y0 = 0","loop":"camX, camY = camera_x(), camera_y()
xdist = (mouse_x()+camX) - self.x
ydist = (mouse_y()+camY) - self.y

# For arrow key movement
keys = [key_is_pressed('arrowRight'), 
        key_is_pressed('arrowLeft'), 
        key_is_pressed('arrowUp'),
        key_is_pressed('arrowDown')
]

# Store previous position for movement rotation
self.x0, self.y0 = self.x, self.y

# Prevent 0 trig errors
if not xdist and not ydist:
    xdist = 1

# Get hypotenuse and adjust x & y for hyp of length 1
magn = hyp(xdist, ydist)
xdist, ydist = xdist/magn, ydist/magn


# Move unless mouse is right on top of player
if mouse_is_pressed('left') and not magn < 25:
    do_move(self, xdist, ydist)

# Allow for arrow-key movement
elif any(keys):
    xdist=ydist=0
    if keys[0
]: xdist = 1
    if keys[1
]: xdist = -1
    if keys[2
]: ydist = 1
    if keys[3
]: ydist = -1
    magn = hyp(xdist, ydist)
    xdist, ydist = xdist/magn, ydist/magn

    do_move(self, xdist, ydist)

else:
    # \"Water resistance\" deteriorate velocity
    self.xv = deter(self.xv, 0.95)
    self.yv = deter(self.yv, 0.95)
    
# Dash
if key_was_pressed(' ') or mouse_was_pressed('right'):
    self.boostx = xdist*13
    self.boosty = ydist*13

# Deteriorate boost velocity
self.boostx, self.boosty = deter(self.boostx, 0.94), deter(self.boosty, 0.94)

# Final movement values in x and y
a, b = (self.xv+self.boostx), (self.yv+self.boosty)

self.x += a
self.y += b


# Distance from zero after move
xdist = self.x - camX
ydist = self.y - camY

# Control camera offset with WASD
# Probably not permanent, just a demonstration of how camera can be offset
if key_is_pressed('d'):
    self.x_off = min(self.x_off+1, 18)
if key_is_pressed('a'):
    self.x_off = max(self.x_off-1, -18)
if key_is_pressed('w'):
    self.y_off = min(self.y_off+1, 16)
if key_is_pressed('s'):
    self.y_off = max(self.y_off-1, -16)

move_camera((xdist - xdist/1.1) + self.x_off,
            (ydist - ydist/1.1) + self.y_off)


# Rotate in direction of movement
Dx, Dy = self.x-self.x0, self.y-self.y0
if not Dx and not Dy: Dx = 1
m = hyp(Dx, Dy)
Dy = Dy/m

if m > 1:
    a = get_angle(Dy) - 90
    self.angle = a if Dx > 0 else -a






# Empty lines because I don't like it when code 
# is at the bottom of the screen"
}
},
{"Background":{
"type":"object script","start":"#Background start

self.sprite = sprite('waterBG.png')","loop":"#Background loop

"
}
},
{"Whale":{
"type":"object script","start":"#Block start


self.sprite = sprite('whale.png')
self.x, self.y = 1500, -420
self.visible = True

self.frames = 0","loop":"#Block loop
try:
    # Exit the loop early if far from player
    pdist = get_dist(self.x, self.y, game.p.x, game.p.y)
    if pdist > 1700:
        self.alpha = 0
        return
except AttributeError: # Whale created before player in Game start
    pass

self.alpha = 1
d = self.frames % 100

if 0 <= d < 50:
    self.y += 0.5
if 50 <= d < 100:
    self.y -= 0.5

self.frames += 1"
}
},
{"Block":{
"type":"object script","start":"#Block start

","loop":"
try:
    # Exit the loop early if far from player
    pdist = get_dist(self.x, self.y, game.p.x, game.p.y)
    if pdist > 1700:
        self.alpha = 0
        return
except AttributeError: # Whale created before player in Game start
    pass

self.alpha = 1
pl = get_collision(self, \"Player\")
if pl:
    p_nf, p_sf, p_wf, p_ef = pl.y0+30, pl.y0-30, pl.x0-30, pl.x0+30

    if p_nf > self.sf or p_sf < self.nf:
        pl.y = pl.y0
    
    if p_ef > self.wf or p_wf < self.ef:
        pl.x = pl.x0
    "
}
}
],
"room":[

],
"texture":[
{"octopus.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.225782.1615621603.octopus.png"
}
},
{"waterBG.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.225782.1615667719.waterBG.png"
}
},
{"whale.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.225782.1615757396.whale.png"
}
},
{"spritesheet.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.225782.1615766188.spritesheet.png"
}
},
{"block.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225969.1615867297.block.png"
}
},
{"debug.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225969.1615873006.debug.png"
}
}
],
"sound":[

],
"function":[
{"imports.py":{
"type":"function script","head":"#File for imports to run before everything
import math
import random
from collections import deque
"
}
},
{"quickfuncs.py":{
"type":"function script","head":"#A collection of helper functions/enums.


def hyp(s, c) -> int:
    \"\"\"Return hypotenuse of right angle triangle.\"\"\"
    return math.sqrt((s**2)+(c**2))

def get_angle(y) -> float:
    \"\"\"Return angle of right angle triangle.
    
    Assumes hypotenuse is 1
    \"\"\"
    return math.degrees(math.asin(y))

def deter(val, k) -> int:
    \"\"\"Helper function that allows for movement deterioration
    while preventing rounding errors.\"\"\"
    if abs(val) <= 0.1: return 0
    return round(val*k, 3)

def get_dist(x1, y1, x2, y2):
    \"\"\"Return the distance between two points.\"\"\"
    return math.sqrt((x2-x1)**2 + (y2-y1)**2)

def scale_objs(amount):
    game.p.scaleX += amount
    game.p.scaleY += amount
    game.bg.scaleX += amount
    game.bg.scaleY += amount
    for obj in game.obj_loader.objs:
        obj.scaleX += amount
        obj.scaleY += amount

def do_move(pl, xdist, ydist):
    # Increase velocity
    pl.xv += (xdist*0.9)
    pl.yv += (ydist*0.9)
    
    # Get total velocity magnetude
    Vhyp = hyp(pl.xv, pl.yv)
    
    # Correct velocity speed
    if Vhyp > 6.5: # 6.5
        pl.xv = (pl.xv/Vhyp)*6.5
        pl.yv = (pl.yv/Vhyp)*6.5
"
}
},
{"gamecreation.py":{
"type":"function script","head":"
def createblock(x, y, w, h, sprname):
    a = Block()
    a.x = x
    a.y = y
    a.scaleX = w/40
    a.scaleY = h/40
    a.sprite = new_sprite(sprname)
    a.wid = w/2
    a.ht = h/2
    a.nf = y+a.ht
    a.sf = y-a.ht
    a.wf = x-a.wid
    a.ef = x+a.wid"
}
}
]
}
}