{"assets":{
"script":[
{"Game":{
"type":"game script","start":"self.bg = Background()\r
level = [\r
        '...CCC...',\r
        '..3W.W3..',\r
        '...W.W...',\r
        '...W.W...',\r
        '...W.W...',\r
        '...W.W...',\r
        '...WXW...',\r
        '...W.W...',\r
        '.2CC.CC2.',\r
        '.W.....W.',\r
        '.1232131.'
]\r
make_map(level)\r
\r
#w = Whale()\r
self.p = Player()\r
\r
#bigwhale = npc()\r
#bigwhale.scaleX = bigwhale.scaleY = 2\r
#bigwhale.x = bigwhale.y = -700\r
\r
struct1 = [(100,-100, 200, 200), (300, -200, 200, 200), (250, -50, 100, 100), \r
(350, 0, 100, 200), (450, -100, 100, 200), (550, -50, 100, 100), (600, 50, 200, 100),\r
(700, -50, 200, 100), (750, 50, 100, 100), (600, -150, 200, 100), (750, -200, 100, 200)
]\r
struct2 = [(50, -50, 100, 100), (100, -150, 200, 100), (200, -300, 200, 200),\r
(50, -400, 100, 200), (150, -450, 100, 100), (-50, -500, 100, 200), (200, -550, 200, 100)
]\r
\r
blockgroup(-1300, -700, \"block.png\", struct1)\r
blockgroup(-500, -700, \"block.png\", struct1)\r
blockgroup(300, -700, \"block.png\", struct1)\r
\r
blockgroup(-1300, 700, \"block.png\", struct1)\r
blockgroup(-500, 700, \"block.png\", struct1)\r
blockgroup(300, 700, \"block.png\", struct1)\r
\r
blockgroup(1100, 800, \"block.png\", struct2)\r
blockgroup(1100, 300, \"block.png\", struct2)\r
blockgroup(1100, -200, \"block.png\", struct2)\r
\r
blockgroup(-1200, 500, \"block.png\", struct2)\r
blockgroup(-1200, 0, \"block.png\", struct2)\r
blockgroup(-1200, -500, \"block.png\", struct2)\r
\r
self.fpslog = int(time.time())\r
self.fpscount = 0","loop":"self.fpscount += 1\r
ntime = int(time.time())\r
\r
if ntime > self.fpslog:\r
    self.fpslog = ntime\r
    print(f\"Frames elapsed in last second: {self.fpscount
}\")\r
    self.fpscount = 0"
}
},
{"Player":{
"type":"object script","start":"#initialise pos, sprite
self.x = 0
self.y = 0
self.z = 5
self.sprite = new_sprite(\"debug.png\")

self.persist = True


#velocity values
self.xv = 0
self.yv = 0
self.boostx, self.boosty = 0, 0

self.y_off = 0
self.x_off = 0

#Store previous values
self.x0 = 0
self.y0 = 0

self.spr_obg = psprite()
self.spr_obg.y = 10
self.visible = False

self.scaleX = 2
self.scaleY = 2","loop":"camX, camY = camera_x(), camera_y()
xdist = (mouse_x()+camX) - self.x
ydist = (mouse_y()+camY) - self.y

# For arrow key movement
keys = [key_is_pressed('arrowRight'), 
        key_is_pressed('arrowLeft'), 
        key_is_pressed('arrowUp'),
        key_is_pressed('arrowDown')
]

# Store previous position for movement rotation
self.x0, self.y0 = self.x, self.y

# Prevent 0 trig errors
if not xdist and not ydist:
    xdist = 1

# Get hypotenuse and adjust x & y for hyp of length 1
magn = hyp(xdist, ydist)
xdist, ydist = xdist/magn, ydist/magn


# Move unless mouse is right on top of player
if mouse_is_pressed('left') and not magn < 16:
    do_move(xdist, ydist)

# Allow for arrow-key movement
elif any(keys):
    xdist=ydist=0
    if keys[0
]: xdist = 1
    if keys[1
]: xdist = -1
    if keys[2
]: ydist = 1
    if keys[3
]: ydist = -1
    magn = hyp(xdist, ydist)
    xdist, ydist = xdist/magn, ydist/magn

    do_move(xdist, ydist)

else:
    # \"Water resistance\" deteriorate velocity
    self.xv = deter(self.xv, 0.95)
    self.yv = deter(self.yv, 0.95)
    
# Dash
if key_was_pressed(' ') or mouse_was_pressed('right'):
    self.boostx = xdist*13
    self.boosty = ydist*13

# Deteriorate boost velocity
self.boostx, self.boosty = deter(self.boostx, 0.94), deter(self.boosty, 0.94)

# Final movement values in x and y
a, b = (self.xv+self.boostx), (self.yv+self.boosty)

self.x += a
self.y += b


# Distance from zero after move
xdist = self.x - camX
ydist = self.y - camY

# Control camera offset with WASD
# Probably not permanent, just a demonstration of how camera can be offset
if key_is_pressed('d'):
    self.x_off = min(self.x_off+1, 18)
if key_is_pressed('a'):
    self.x_off = max(self.x_off-1, -18)
if key_is_pressed('w'):
    self.y_off = min(self.y_off+1, 16)
if key_is_pressed('s'):
    self.y_off = max(self.y_off-1, -16)

move_camera((xdist - xdist/1.1) + self.x_off,
            (ydist - ydist/1.1) + self.y_off)


# Rotate in direction of movement
Dx, Dy = self.x-self.x0, self.y-self.y0
if not Dx and not Dy: Dx = 1
m = hyp(Dx, Dy)
Dy = Dy/m

if m > 1:
    a = get_angle(Dy) - 90
    self.angle = a if Dx > 0 else -a

update_spr(self.spr_obg, self.x, self.y, self.angle)






# Empty lines because I don't like it when code 
# is at the bottom of the screen"
}
},
{"Background":{
"type":"object script","start":"#Background start
#darkbg is 1200x1000
self.sprite = sprite('darkbg.png')
self.scaleX = 2
self.scaleY = 1.5","loop":"#Background loop

"
}
},
{"Block":{
"type":"object script","start":"#Block start

","loop":"

# Exit the loop early if far from player
pdistx = self.x - game.p.x
pdisty = self.y - game.p.y


if abs(pdistx) > 1000 or abs(pdisty) > 600:
    self.visible = False
    return


self.visible = True
pl = get_collision(self, \"Player\")
if pl:
    p_nf, p_sf, p_wf, p_ef = pl.y0+40, pl.y0-40, pl.x0-40, pl.x0+40

    if p_nf < self.sf or p_sf > self.nf:
        pl.y = pl.y0

    elif p_ef < self.wf or p_wf >= self.ef:
        pl.x = pl.x0
    "
}
},
{"psprite":{
"type":"object script","start":"#Hitbox start
self.scaleX = 0.6
self.scaleY = 0.6
self.sprite = new_sprite(\"octopus.png\")
\"\"\"
self.spr = new_sprite(\"whalesprites.png\", 2, 2)
self.anim = new_animation(self.spr, 5, 0, 3)
set_animation(self, self.anim)

self.isleft = False
\"\"\"","loop":"

'''
if not 90<=k<=270 and not self.isleft:
    self.scaleX = -1*self.scaleX
    self.isleft = True
'''"
}
},
{"npc":{
"type":"object script","start":"#Block start


self.sprite = sprite('whale.png')
self.x, self.y = 1500, -420
self.visible = True

self.frames = 0","loop":"
try:
    # Exit the loop early if far from player
    pdist = get_dist(self.x, self.y, game.p.x, game.p.y)
    if pdist > 1700:
        self.alpha = 0

        return
    else:
        if not self.visible:
            self.visible = True
except AttributeError: # Whale created before player in Game start
    pass


self.alpha = 1
pl = get_collision(self, \"Player\")
if pl:
    pass
    "

}
},
{"Tile":{
"type":"object script","start":"# Empty (at least for now) class that is used to make tiles\r
# Sprite gets set anyways","loop":""
}
}
],
"room":[

],
"texture":[
{"octopus.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.225782.1615621603.octopus.png"
}
},
{"waterBG.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.225782.1615667719.waterBG.png"
}
},
{"whale.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.225782.1615757396.whale.png"
}
},
{"spritesheet.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.225782.1615766188.spritesheet.png"
}
},
{"ground1.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226216.1615868393.ground1.png"
}
},
{"ground2.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226216.1615868400.ground2.png"
}
},
{"ground3.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19203.226216.1615868409.ground3.png"
}
},
{"debug.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225969.1615873006.debug.png"
}
},
{"darkbg.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225969.1615919713.darkbg.png"
}
},
{"whalesprites.png":{
"type":"image","uri":"https://s3.us-west-1.amazonaws.com/media.pixelpad.io/__ASSET__.19216.225969.1615934963.whalesprites.png"
}
}
],
"sound":[

],
"function":[
{"imports.py":{
"type":"function script","head":"#File for imports to run before everything
import math
import random
import time"
}
},
{"quickfuncs.py":{
"type":"function script","head":"#A collection of helper functions/enums.


def hyp(s, c) -> int:
    \"\"\"Return hypotenuse of right angle triangle.\"\"\"
    return math.sqrt((s**2)+(c**2))

def get_angle(y) -> float:
    \"\"\"Return angle of right angle triangle.
    
    Assumes hypotenuse is 1
    \"\"\"
    return math.degrees(math.asin(y))

def deter(val, k) -> int:
    \"\"\"Helper function that allows for movement deterioration
    while preventing rounding errors.\"\"\"
    if abs(val) <= 0.1: return 0
    return round(val*k, 3)

def get_dist(x1, y1, x2, y2):
    \"\"\"Return the distance between two points.\"\"\"
    return math.sqrt((x2-x1)**2 + (y2-y1)**2)

def do_move(xdist, ydist):
    # Increase velocity
    game.p.xv += (xdist*0.9)
    game.p.yv += (ydist*0.9)
    
    # Get total velocity magnetude
    Vhyp = hyp(game.p.xv, game.p.yv)
    
    # Correct velocity speed
    if Vhyp > 6.5: # 6.5

        game.p.xv = (game.p.xv/Vhyp)*6.5
        game.p.yv = (game.p.yv/Vhyp)*6.5"
}
},
{"make_map.py":{
"type":"function script","head":"tile_map = {
    'C': sprite('ground1.png'), # placeholder ceiling
    'W': sprite('ground2.png'), # placeholder wall
    '1': sprite('ground1.png'),
    '2': sprite('ground2.png'),
    '3': sprite('ground3.png'),

}



def make_map(layout):
    for i in range(len(layout)):
        if 'X' in layout[i
]:
            origin = (layout[i
].index('X'), i)
    
    for i in range(len(layout)):
        for j in range(len(layout[i
])):
            if layout[i
][j
] in '. X':
                continue

            t = Tile()

            x = abs(100 * (origin[0
]-j))
            x *= -1 if j < origin[0
] else 1
            t.x = x

            y = abs(100 * (origin[1
]-i))
            y *= 1 if i < origin[1
] else -1
            t.y = y

            t.sprite = tile_map[layout[i
][j
]
]"
}
},
{"gamecreation.py":{
"type":"function script","head":"
def createblock(x, y, w, h, sprname=\"block.png\"):
    \"\"\"Basic opaque block. Takes args for pos, size, and optional block sprite.\"\"\"
    #construct block and set args
    a = Block()
    a.x = x
    a.y = y
    #This works for 40x40 sprite. For other sprites, change divisor accordingly
    a.scaleX = w/40
    a.scaleY = h/40
    a.sprite = new_sprite(sprname)
    #store these for collision purposes
    a.wid = w/2
    a.ht = h/2
    a.nf = y+a.ht
    a.sf = y-a.ht
    a.wf = x-a.wid
    a.ef = x+a.wid

def blockgroup(x, y, sprname, posl):
    \"\"\"Creates a group of blocks at a x and y position,
    given a list  of block constructs. posl is a list of tuples,
    each of the form (x, y, w, h).\"\"\"
    for bx, by, bw, bh in posl:
        createblock(bx+x, by+y, bw, bh, sprname)"
}
}
]
}
}